<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MVC 和 MTV的区别</title>
    <url>/2020/08/03/MVC%20%E5%92%8C%20MTV%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>把数据存取逻辑、业务逻辑和表现逻辑组合在一起的概念被称为软件架构的 Model-View-Controller (MVC)模式。 在这个模式中， Model 代表数据存取层，View 代表的是系统中选择显示什么和怎么显示的部分，Controller 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803141443.png"></p>
<h2 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h2><p>利用MVC去理解django的MTV</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">M 代表模型（Model）</td>
<td align="left">数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。与MVC中的M功能相同，负责数据处理，内嵌了ORM框架。 负责业务对象和数据库的关系映射。</td>
</tr>
<tr>
<td align="left">T 代表模板(Template)</td>
<td align="left">表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。与MVC中的V功能相同，负责封装构造要返回的html，内嵌了模板引擎。 如何把页面展示给用户HTML</td>
</tr>
<tr>
<td align="left">V 代表视图（View）</td>
<td align="left">业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。与MVC中的C功能相同，接收HttpRequest，业务处理，返回HttpResponse。 负责业务逻辑，调用Model和Template</td>
</tr>
</tbody></table>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803141457.png"></p>
<ol>
<li>web服务器(mid)收到一个http请求</li>
<li>django在URL_conf里面找到对应的视图(view)函数处理http请求</li>
<li>视图函数调用相应的数据模型来存取数据，调用相应的模板向用户展现页面</li>
<li>视图函数处理结束后返回http的响应给web服务器</li>
<li>web服务器讲响应发给客户端</li>
</ol>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803141513.png"></p>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 使用terminal写入img镜像</title>
    <url>/2020/08/03/Mac%20%E4%BD%BF%E7%94%A8terminal%E5%86%99%E5%85%A5img%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先对U盘进行格式化，利用SD Card Formatter,这款格式化工具可以从SD官网下载。</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1.进入目录</p>
<p>插入要写入的sd卡，进入Mac上存放img镜像文件的目录，比如我的就是放在Desktop上的raspberryiso文件夹，那么terminal的命令就是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/desktop/rasiberryiso</span><br></pre></td></tr></table></figure>

<p>2.列出目前系统上的所有磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure>

<p>在terminal里找到你要写入的磁盘的编号.</p>
<p>3.推出此磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (&lt;disk#&gt;换成你要写入的磁盘编号）</span></span><br><span class="line">diskutil unmountDisk /dev/&lt;disk<span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure>


<p>4.用dd命令将树莓派系统镜像写入SD卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd bs=1m <span class="keyword">if</span>=&lt;your image file name&gt;.img of=/dev/&lt;disk<span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure>

<p>输入这个命令后系统会提示你输入密码，此时输入你电脑账户的密码即可。然后开始写入。如果没有载入新的命令行，说明正在写入，这时候就需要耐心等待，有事需要几个小时，根据你文件大小和U盘传输速率来定。</p>
]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2020/08/04/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p>二分法比较重要，然后又一定的模板。在此基础上可以进行一系列的修改，然后达到题目要求。需要注意有几个地方，二分法容易出错。</p>
<h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><hr>
<p>二分法分<code>整数二分</code>和<code>浮点数二分</code>。</p>
<p>二分法使用的范围： 是以一个点，满足一个性质，可以把一个区间分成两个部分。这个性质可以是<code>单调性</code>也可以是其他的性质。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804093952.png"></p>
<p>两个模板可以求两个点：</p>
<p>第一个求黑色点的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// l, r 分别表示left左边界，和r有边界。</span></span><br><span class="line"><span class="comment">// cheak() 表示是否中当前的划分的性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid  = l + r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cheak(mid)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个球蓝色的点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// l, r 分别表示left左边界，和r有边界。</span></span><br><span class="line"><span class="comment">// cheak() 表示是否中当前的划分的性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span>( l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cheak(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分的取整比较重要，有时候需要进行向上取证。不然就会一直进行循环。 当 <code>l = mid </code>的时候需要进行向上取证，而 <code>r = mid</code> 不需要进行向上取整数。</p>
<ul>
<li>l = mid的时候， 当l = r - 1, 如果是mid = l + r &gt;&gt; 1，如果cheak(mid) == true, 那么l = mid, 区间任然是<code>[l, r]</code></li>
<li>所以l = mid 的时候， mid = l + r + 1 &gt;&gt; 1; 进行向上取整数。</li>
<li>r不用此考虑，因为r本身就是向下取整，而且 while ( l &lt; r) 当r向下取整后就会终止循环。</li>
<li>所以在归并排序中mid = l + r &gt;&gt; 1, 左边分成<code>[l, mid]</code>右边是<code>[mid + 1, r]</code>区间。</li>
</ul>
<h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><hr>
<p>浮点数二分不用考虑边界情况，左边界和右边界都是一样的。以一个点向左划分和向右划分都是一样的。所以不存在划分的边界条件。</p>
<p>以开三次方为例子。数据范围 -1000000  &lt;= n &lt;= 1000000</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( mid * mid * mid &gt;= n) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid * mid * mid &lt;= n) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>

<p>还有一种写法，就是循环100次数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid * mid * mid &gt;-= n) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>


<p>PS:</p>
<p>这里r - l &gt; 1e-8 是提升精度的方式, 要求保留6位小数点的话，那么精度就要求1e8。循环100次也是提升精度的方式。 这里<code>mid * mid * mid &gt;= x</code>， 等于符号无所谓，可有可无，因为取不到等于的情况。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2020/08/04/%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p>前缀和唯一作用就是对一段区间方便求和。差分是前缀和的逆运算</p>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>一维数组前缀和：</p>
<p>规定： <code>s[i] = a[1] + a[2] + a[3] ...  + a[i]</code></p>
<p>所以， 方便求和 <code>a[i] ~ a[j]</code> :</p>
<p><code>s[j] = a[1] + a[2] + a[3]    ...  + a[i - 1] + a[i] + ... + a[j]</code></p>
<p><code>s[i - 1] = a[1] + a[2] + a[3] ... + a[i - 1]</code></p>
<p>所以 <code>s[j] - s[i - 1]</code> = $\sum_{i}^j a[i]$</p>
<p>c++ 模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 存放的时候一定注意是从1开始存放，这样前缀和 i - 1 就不会越界</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 求前缀和</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + q[i];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出 i ~ j 的累加和</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s[j] - s[i - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组前缀和：</p>
<p>这样一个二维数组，求蓝色部分的前缀和。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804094727.png"></p>
<p>求蓝色区域的面积。可以分别为两个部分的前缀和，一个是x轴方向的前缀和，一个是y方向的前缀和。</p>
<p><code>s[i][j]</code> 表示i * j 的整个数组的分别，比如 3 * 3 表示就是蓝色方框的数值。</p>
<p>所以<code>s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]</code></p>
<p>这里减去<code>s[i - 1][j - 1]</code> 是因为<code>s[i - 1][j] 和 s[i][j - 1]</code>都包含<code>s[i - 1][j - 1]</code>这个部分。</p>
<p>所以蓝色部分的用<code>s[i][j] </code>表示可以用<code>x1, y1, x2, y2</code>表示为：</p>
<p>蓝色部分的面积 = <code>s[x2][y2] = s[x1 - 1][y2]  + s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</code></p>
<p>所以c++ 代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="number">0</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">cin</span> &gt;&gt; s[i][j];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span></span></span><br><span class="line"><span class="function"><span class="params">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分运算是前缀和的逆运算。</p>
<p>有一个数组 <code>a[N]</code>， 构造一个辅助数组<code>b[N]</code>，</p>
<p>使得满足两个性质：</p>
<ol>
<li><code>a[i] = b[1] + b[2] + b[3] + ... + b[i]</code></li>
<li><code>b[i] = a[i] - a[i - 1]</code></li>
</ol>
<p>唯一一个应用就是在区间 <code>[l, r]</code> 区间内都加上 $c$。可以做到$O(1)$的复杂度。</p>
<ul>
<li>因为<code>a[i]</code>是<code>b[1 ~ i]</code>的前缀和。</li>
<li>在<code>b[l] + c</code>， 在 <code>b[r + 1] - c</code>,再求前缀和。</li>
</ul>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804094743.png"></p>
<p>在利用<code>b[i]</code>数组求<code>a[i]</code>的时候，在<code>b[l] + c</code>那么l之后的数据都会 + c，但是只要l ~ r区间 + c，所以在 r + 1的位置 - c就行了。</p>
<p>此外需要注意的是，在初始化b数组的时候，那么那么可以理解为<code>b[1 ~ i]</code> 都是0 然后在<code>l ~ l</code>的区间插入数据就可以了。</p>
<p>c++ 代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 读入a数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造b数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) insert(i, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行m次数的插入操作</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        insert(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终的数组, 利用前缀和进行构造</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维矩阵的差分运算：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804094805.png"></p>
<p>所以插入操作就是：</p>
<p><code>b[x1][y1] += c        </code><br><code>b[x1][y2 + 1] -= c    </code><br><code>b[x2 + 1][y1] -= c    </code><br><code>b[x2 + 1][y2 + 1] += c</code></p>
<p>接下来就是求前缀和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="comment">// 读取数组a</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造数组b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            insert(i, j, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        insert(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库配置和ORM机制</title>
    <url>/2020/08/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E5%92%8CORM%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>首先在setting里面会配置好数据库的信息：这里默认的是使用sqlite3的数据库</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python支持这些引擎，详情见： <a href="https://docs.djangoproject.com/en/3.0/ref/settings/#databases">https://docs.djangoproject.com/en/3.0/ref/settings/#databases</a></p>
<ul>
<li>‘django.db.backends.postgresql’</li>
<li>‘django.db.backends.mysql’</li>
<li>‘django.db.backends.sqlite3’</li>
<li>‘django.db.backends.oracle’</li>
</ul>
<h4 id="切换成MySQL数据库"><a href="#切换成MySQL数据库" class="headerlink" title="切换成MySQL数据库"></a>切换成MySQL数据库</h4><p>首先需要安装MySQL的python驱动库。这里使用mysqlclient</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure>

<p>然后需要在setting里面更改数据库引擎和配置。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;blog_project&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;demo9090&#x27;</span>,</span><br><span class="line">        <span class="comment">#  这里可选配置</span></span><br><span class="line">        <span class="comment"># &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,</span></span><br><span class="line">        <span class="comment"># &#x27;PORT&#x27;: &#x27;5432&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后利用Navicat连接数据库，之后创建数据库。<br><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150514.png"></p>
<p>接下来进行表单同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>同步表单后就可以看到表单数据了。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150525.png"></p>
<h4 id="ORM机制"><a href="#ORM机制" class="headerlink" title="ORM机制"></a>ORM机制</h4><p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150552.png"></p>
<p>对象关系映射(英语:Object Relational Mapping,简称ORM)，用于实现面向对象编程语言里不同类型系统的数据之间的转换.换句说，就是用面向对象的方式去操作数据库的创建表，增加、修改、删除、查询等操作</p>
<p>比如： 可以在QuerySet中调用query属性</p>
<p>在<code>views.py</code>中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_list = User.Objects.all()</span><br><span class="line">    print(user_list.query)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;blog/index.html&quot;</span>, &#123;<span class="string">&quot;user&quot;</span>: user_list&#125;)</span><br></pre></td></tr></table></figure>

<p>这样会得到一套sql语句，然后再Navicat中查询一下query(询问)</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150607.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`auth_user`</span>.<span class="string">`id`</span>, <span class="string">`auth_user`</span>.<span class="string">`password`</span>, <span class="string">`auth_user`</span>.<span class="string">`last_login`</span>, <span class="string">`auth_user`</span>.<span class="string">`is_superuser`</span>, <span class="string">`auth_user`</span>.<span class="string">`username`</span>, <span class="string">`auth_user`</span>.<span class="string">`first_name`</span>, <span class="string">`auth_user`</span>.<span class="string">`last_name`</span>, <span class="string">`auth_user`</span>.<span class="string">`email`</span>, <span class="string">`auth_user`</span>.<span class="string">`is_staff`</span>, <span class="string">`auth_user`</span>.<span class="string">`is_active`</span>, <span class="string">`auth_user`</span>.<span class="string">`date_joined`</span> <span class="keyword">FROM</span> <span class="string">`auth_user`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150626.png"></p>
<p>ORM优缺点</p>
<ol>
<li><p>ORM使得我们通过数据库交互变的简单易行，并且完全不用考虑该死的SQL语句，快速开发，由此而来</p>
</li>
<li><p>可以避免一些你搜程序猿写sql语句带来的性能和效率问题</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>性能有所牺牲。不过现在的各种ORM框架都在尝试使用各种方法来减轻这个问题(LazyLoad，Cache)，效果还是很显著的</p>
</li>
<li><p>对于个别复杂查询，ORM仍然力不从心。为了 解决这个问题，ORM框架一般也提供了直接原生sql的方式</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter + Nginx</title>
    <url>/2020/08/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Jupyter/</url>
    <content><![CDATA[<p>在服务器上部署Jupyter，使Jupyter成为一个云笔记本</p>
<hr>
<h2 id="创建账户并安装Jupyter-和-Nginx"><a href="#创建账户并安装Jupyter-和-Nginx" class="headerlink" title="创建账户并安装Jupyter 和 Nginx"></a>创建账户并安装Jupyter 和 Nginx</h2><p>首先创建一个账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser ubuntu</span><br><span class="line"><span class="comment"># 添加到管理组</span></span><br><span class="line">adduser ubuntu sudo</span><br></pre></td></tr></table></figure>

<p>创建脚本，运行一下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sudo apt-get update -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install build-essential libssl-dev libpq-dev libcurl4-gnutls-dev libexpat1-dev gettext unzip -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install supervisor -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install python3-pip python3-dev python3-venv -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install nano -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install git -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install nginx curl -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install ufw -y</span><br><span class="line"></span><br><span class="line">sudo ufw allow <span class="string">&#x27;Nginx Full&#x27;</span></span><br><span class="line"></span><br><span class="line">sudo ufw allow ssh</span><br><span class="line"></span><br><span class="line">sudo python3 -m pip install jupyter</span><br><span class="line"></span><br><span class="line">sudo service supervisor start</span><br><span class="line"></span><br><span class="line">sudo apt autoremove -y</span><br></pre></td></tr></table></figure>

<p>通过ip访问主机： <a href="http://47.100.78.128/">http://47.100.78.128</a> 访问你的主机。应该会出现一个Nginx的初始界面。</p>
<hr>
<h2 id="进行Jupyter-配置"><a href="#进行Jupyter-配置" class="headerlink" title="进行Jupyter 配置"></a>进行Jupyter 配置</h2><p>配置Jupyter config：</p>
<p>生成配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成哈希密码</span></span><br><span class="line">ipython -c <span class="string">&quot;from notebook.auth import passwd; passwd()&quot;</span></span><br></pre></td></tr></table></figure>
<p>更新配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /home/ubuntu/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>

<p>添加配置到config里面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c = get_config()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kernel config</span></span><br><span class="line">c.IPKernelApp.pylab = <span class="string">&#x27;inline&#x27;</span>  <span class="comment"># if you want plotting support always in your notebook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Notebook config</span></span><br><span class="line"></span><br><span class="line">c.NotebookApp.allow_origin = <span class="string">&#x27;http://107.21.189.212&#x27;</span> <span class="comment"># put your public IP Address here</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">c.NotebookApp.allow_remote_access = True</span><br><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line">c.NotebookApp.password = u<span class="string">&#x27;sha1:45e47cb75d9e:49dc0b09f4e671485b6113c1e2c5a13d7d37fa78&#x27;</span></span><br><span class="line">c.NotebookApp.port = 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># For https &amp; letsencrypt later</span></span><br><span class="line"><span class="comment"># c.NotebookApp.certfile = u&#x27;/your/cert/path/cert.pem&#x27;</span></span><br><span class="line"><span class="comment"># c.NotebookApp.keyfile = u&#x27;/your/cert/path/privkey.pem&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Nginx设置"><a href="#Nginx设置" class="headerlink" title="Nginx设置"></a>Nginx设置</h2><p>这里安装的是Nginx，使用Apache2原理一样只是麻烦点。创建<code>jupyter_config</code>配置文件,名称可以任意：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/jupyter_app.conf</span><br></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name jupyter_notebook;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        include proxy_params;</span><br><span class="line">        proxy_pass http://localhost:8888;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_buffering off;</span><br><span class="line">        proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        proxy_set_header Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">        proxy_read_timeout 86400;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您打算使用自定义域，请替换<code>server_name jupyter_notebook;</code>为<code>server_name your_custom_domain.com;</code></p>
<p>启动配置文件。并重启服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /etc/nginx/sites-available/jupyter_app.conf /etc/nginx/sites-enabled/jupyter_app.conf</span><br><span class="line"></span><br><span class="line">sudo rm /etc/nginx/sites-enabled/default</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="创建后台运行Jupyter"><a href="#创建后台运行Jupyter" class="headerlink" title="创建后台运行Jupyter"></a>创建后台运行Jupyter</h2><p>创建配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/supervisor/conf.d/my_jupyter.conf</span><br></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[program:my_jupyter]</span><br><span class="line">user=ubuntu</span><br><span class="line">directory=/home/ubuntu</span><br><span class="line"><span class="built_in">command</span>=jupyter notebook</span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">stdout_logfile=/var/<span class="built_in">log</span>/my_jupyter/stdout.log</span><br><span class="line">stderr_logfile=/var/<span class="built_in">log</span>/my_jupyter/stderr.log</span><br></pre></td></tr></table></figure>

<p>启动配置程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建日志</span><br><span class="line">sudo mkdir &#x2F;var&#x2F;log&#x2F;my_jupyter</span><br><span class="line"></span><br><span class="line"># 启动配置</span><br><span class="line">sudo supervisorctl reread</span><br><span class="line">sudo supervisorctl update</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p>此方法还可以使用JupyterLab和JupyterHub</p>
</li>
<li><p>其他想不起来了</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
