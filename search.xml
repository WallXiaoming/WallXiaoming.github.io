<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django - MVC 和 MTV的区别</title>
    <url>/2020/08/03/Django/Django%20-%20MVC%20%E5%92%8C%20MTV%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="MVC">MVC</h2>
<p>把数据存取逻辑、业务逻辑和表现逻辑组合在一起的概念被称为软件架构的 Model-View-Controller (MVC)模式。 在这个模式中， Model 代表数据存取层，View 代表的是系统中选择显示什么和怎么显示的部分，Controller 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803141443.png" alt=""></p>
<h2 id="MTV">MTV</h2>
<p>利用MVC去理解django的MTV</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">M 代表模型（Model）</td>
<td style="text-align:left">数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。与MVC中的M功能相同，负责数据处理，内嵌了ORM框架。 负责业务对象和数据库的关系映射。</td>
</tr>
<tr>
<td style="text-align:left">T 代表模板(Template)</td>
<td style="text-align:left">表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。与MVC中的V功能相同，负责封装构造要返回的html，内嵌了模板引擎。 如何把页面展示给用户HTML</td>
</tr>
<tr>
<td style="text-align:left">V 代表视图（View）</td>
<td style="text-align:left">业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。与MVC中的C功能相同，接收HttpRequest，业务处理，返回HttpResponse。 负责业务逻辑，调用Model和Template</td>
</tr>
</tbody>
</table>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803141457.png" alt=""></p>
<ol>
<li>web服务器(mid)收到一个http请求</li>
<li>django在URL_conf里面找到对应的视图(view)函数处理http请求</li>
<li>视图函数调用相应的数据模型来存取数据，调用相应的模板向用户展现页面</li>
<li>视图函数处理结束后返回http的响应给web服务器</li>
<li>web服务器讲响应发给客户端</li>
</ol>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803141513.png" alt=""></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - ORM常用操作</title>
    <url>/2020/08/03/Django/Django%20-%20ORM%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<p>objects:为models默认管理器， 在插入的时候可以使用id也可以使用对象， 这里返回的是一个object</p>
<p>详情: <a href="https://docs.djangoproject.com/zh-hans/3.0/topics/db/queries/">https://docs.djangoproject.com/zh-hans/3.0/topics/db/queries/</a></p>
<p>插入<code>多对多关系</code>的时候需要分布操作</p>
<p>一、 增加crate 和 save方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用create创建</span></span><br><span class="line">Author.object.cerate(name=<span class="string">&quot;李四&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用save方法创建</span></span><br><span class="line">xiaoming = Author(name=<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">xiaoming.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在创建主键关系的时候，比如OneToOneField, ManyTOManyField, ForeignKey, 在author绑定的时候使用author_id绑定</span></span><br><span class="line">xiaoming_detail = AuthorDetail(sex=<span class="string">&quot;0&quot;</span>, email=<span class="string">&quot;xiaoming@email.com&quot;</span>, address=<span class="string">&quot;北京xxxx&quot;</span>, brithday=<span class="string">&quot;1900-8-8&quot;</span>, author_id=<span class="string">&quot;3&quot;</span>)</span><br><span class="line">xiaoming_detail.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一条出版社信息</span></span><br><span class="line">pub = Publisher()</span><br><span class="line">pub.name = <span class="string">&quot;成都工业&quot;</span></span><br><span class="line">pub.address = <span class="string">&quot;成都xxx&quot;</span></span><br><span class="line">pub.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">pub.state_province = <span class="string">&quot;四川&quot;</span></span><br><span class="line">pub.country = <span class="string">&quot;中国&quot;</span></span><br><span class="line">pub.website = <span class="string">&quot;www.google.com&quot;</span></span><br><span class="line">pub.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加书籍信息，多对多是两张表，author和数据对应的是一张表</span></span><br><span class="line">book = Book(title=<span class="string">&quot;这是一本书&quot;</span>, publisher=pub, publication_date=<span class="string">&quot;2017-8-9&quot;</span>)</span><br><span class="line"><span class="comment"># 所以这需要先保存</span></span><br><span class="line">book.save()</span><br><span class="line">book.author.add(xiaoming)</span><br><span class="line">li = Author.objects.get(id=<span class="number">2</span>)</span><br><span class="line">book.author.add(li)</span><br></pre></td></tr></table></figure>
<p>然后就会在表格中多一个。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811072449.png" alt=""></p>
<p>二、 修改update 和 save方法</p>
<p>注意update修改于<code>QuerySet</code>, <code>get</code>获取的是<code>object</code>对象，<code>filter</code> 获取的是<code>QuerySet</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用 save方法修改</span></span><br><span class="line">li = Author.objects.get(id=<span class="number">2</span>)</span><br><span class="line">li.name = <span class="string">&quot;最强王者&quot;</span></span><br><span class="line">li.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 update方法修改, QuerySet</span></span><br><span class="line">b = Publisher.objects.filter(id=<span class="number">1</span>)</span><br><span class="line">b.update(website=<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>三、 查询(惰性查询)和删除</p>
<ol>
<li>
<p>QuerySet 是惰性的 —— 创建 QuerySet 并不会引发任何数据库活动。你可以将一整天的过滤器都堆积在一起，Django 只会在 QuerySet 被 计算 时执行查询操作。在使用xxx.objects.all()的时候，并没有直接去数据库查询，但是，如果使用就会进行数据库的实际查询。</p>
</li>
<li>
<p>delete删除, QuerySet和object都行</p>
</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除是级联删除，on_delete=models.CASCADE, 删除了张三，那么authorDetail里面的张三也会被删除</span></span><br><span class="line">Author.objects.filter(id=<span class="number">1</span>).delete()</span><br><span class="line">Author.objects.get(id=<span class="number">2</span>).delete()</span><br></pre></td></tr></table></figure>
<p>查询方法有： <a href="https://docs.djangoproject.com/zh-hans/3.0/topics/db/queries/">https://docs.djangoproject.com/zh-hans/3.0/topics/db/queries/</a></p>
<p>QuerySet不支负数索引</p>
<ul>
<li>get()</li>
<li>filter()</li>
<li>first()</li>
<li>last()</li>
<li>all()</li>
<li>count()</li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - ORM查询</title>
    <url>/2020/08/03/Django/Django%20-%20ORM%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<hr>
<p>详情：</p>
<p><a href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/">https://docs.djangoproject.com/en/3.0/ref/models/querysets/</a><br>
<a href="https://docs.djangoproject.com/zh-hans/3.0/topics/db/queries/">https://docs.djangoproject.com/zh-hans/3.0/topics/db/queries/</a></p>
<p>查询的对象有两种一种是直接查询项目object， 一种是查询QuerySet。</p>
<p>QuerySet特点：</p>
<ol>
<li>惰性查询</li>
<li>可迭代</li>
<li>可切片</li>
<li>可索性，但是索引不能为负数</li>
</ol>
<p>常见查询：</p>
<ul>
<li><code>get(**kwargs)</code> 返回object， 事实具体查询，如果查出多个object或者没有查到都会报错，可以用异常捕捉进行调试</li>
<li><code>all()</code>  查询所有结果</li>
<li><code>filter(**kwargs)</code>返回QuerySet， 条件查询</li>
<li><code>exclude(**kwargs)</code> 与filter相反，返回条件不同的结果</li>
<li><code>order_by(*fileds)</code> 对查询结果排序</li>
<li><code>reverse()</code> 对查询结果反向排列</li>
<li><code>distinct()</code> 返回结果中剔除重复记录</li>
<li><code>values(*fileds)</code> 返回一个valueQuerySet, 内容以为字典的形式</li>
<li><code>values_list(*fileds)</code> 返回alueQuerySet， 内容以元组的形式</li>
<li><code>count()</code>返回QuerySet中查询匹配的数目</li>
<li><code>first()</code>返回第一条记录，等价于[:1][0]</li>
<li><code>last()</code>返回最后一条记录， 等价于[::-1][0]</li>
<li><code>exists()</code> 如果QuerySet中有数据返回True， 否则返回False</li>
</ul>
<p>多表查询：</p>
<ul>
<li>__xx, 可以使用__xxx使用双下划线对属性进行直接显示, 可用内连接与外连接。</li>
<li>_set, 提供某一个对象访问set的数据表，是主键类关联外键类型。ForeignKey. 主键就是多对1的那个1, 外键就是那个多。</li>
</ul>
<p>聚集查询和分组查询：</p>
<ol>
<li><code>annotate(*args, **kwargs)</code>, 以QuerySet集合对象添加注释， 通过集合中每个关联对象集合。用于分组查询</li>
<li><code>aggregate(*args, **kwargs)</code>, 返回一个聚合值的字典。</li>
</ol>
<p>聚集查询和分组查询都在<code>from django.db.models import Count</code>中</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于所有书的价格求和</span></span><br><span class="line">Book.objects.aggregate(Sum(<span class="string">&#x27;prices&#x27;</span>))</span><br><span class="line"><span class="comment"># 或者使用kwargs， key就是显示的key， values = Sum(&quot;prices&quot;)</span></span><br><span class="line">Book.objects.aggregate(boo_all_prices=Sum(<span class="string">&#x27;prices&#x27;</span>))</span><br><span class="line"><span class="comment"># 或者对单独一组的数据进行求和</span></span><br><span class="line">Book.objects.filter(publisher__name=<span class="string">&quot;成都工业&quot;</span>).aggregate(Sum(<span class="string">&#x27;prices&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先利用values函数进行分组，然后再利用annotate进行分组求和</span></span><br><span class="line">Book.objects.values(<span class="string">&quot;publisher&quot;</span>).annotate(Sum(<span class="string">&#x27;prices&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求每个出版社出的书的总的价格</span></span><br><span class="line"><span class="comment"># 对出版社进行分组，在对价格求和</span></span><br><span class="line">Book.objects.values(<span class="string">&quot;publisher__name&quot;</span>).annotate(Sum(<span class="string">&quot;prices&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>此外还一颗使用原生sql语句进行查询：</p>
<p>详情：</p>
<p><a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/querysets/#extra">https://docs.djangoproject.com/zh-hans/3.0/ref/models/querysets/#extra</a><br>
<a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/querysets/#raw">https://docs.djangoproject.com/zh-hans/3.0/ref/models/querysets/#raw</a></p>
<p>比如extra(), 和raw()</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - admin管理</title>
    <url>/2020/08/03/Django/Django%20-%20admin%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
<p>详情：</p>
<p><a href="https://docs.djangoproject.com/en/3.0/ref/contrib/admin/">https://docs.djangoproject.com/en/3.0/ref/contrib/admin/</a></p>
<p>admin的使用：</p>
<ul>
<li>使用register函数</li>
<li>使用装饰器</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> myproject.myapp.models <span class="keyword">import</span> Author</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">admin.site.register(Author, AuthorAdmin)</span><br></pre></td></tr></table></figure>
<p>使用装饰器</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Author</span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(Author)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>list_display 指定显示的字段</li>
<li>search_fields 指定搜索的字段</li>
<li>list_filter 指定列表过滤器</li>
<li>ordering 指定排序</li>
<li>fields\exclude 指定编辑表单和不需要编辑的表单</li>
<li>fieldsets 设置分组表单</li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - models模型配置</title>
    <url>/2020/08/03/Django/Django%20-%20models%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr>
<p>几种关系：</p>
<p>一对一的关系： 一个作者只能有一个作者的详情，就是一对一</p>
<p>多对一的关系： 多本书籍对应一个出版社</p>
<p>多对多的关系： 一本书对应多个作者，一个作者也能对应多书籍</p>
<p><code>models.CASCADE</code> - 表示级联</p>
<ul>
<li>一对一的关系 OneToOneField(on_delete=models.CASCADE)</li>
<li>多对一的关系 ForeignKey(on_delete=models.CASCADE)</li>
<li>多对多的关系 ManyToManyField</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(<span class="string">&quot;名称&quot;</span>, max_length=<span class="number">30</span>)  <span class="comment"># 可以在第一个position添加为verbose_name</span></span><br><span class="line">    address = models.CharField(max_length=<span class="number">50</span>, verbose_name=<span class="string">&quot;地址&quot;</span>)  <span class="comment"># 可以使用verbose_name标签</span></span><br><span class="line">    city = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    state_province = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    country = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    website = models.URLField()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorDetail</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    sex = models.BooleanField(max_length=<span class="number">1</span>, choices=((<span class="number">0</span>, <span class="string">&quot;男&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;女&quot;</span>)))</span><br><span class="line">    email = models.EmailField()</span><br><span class="line">    address = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    brithday = models.DateField()</span><br><span class="line">    author = models.OneToOneField(Author, on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    authors = models.ManyToManyField(Author)</span><br><span class="line">    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)</span><br><span class="line">    publication_date = models.DateField()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里需要注意，就是你之前如果migrate数据库，那么有时候会报错，在进行迁移的时候是加迁移，并不会再创建表格。</p>
<p>定义数据模型的扩展属性 <code>class Meta</code>：</p>
<p>详细文档：<br>
<a href="https://docs.djangoproject.com/zh-hans/3.0/topics/db/models/">https://docs.djangoproject.com/zh-hans/3.0/topics/db/models/</a><br>
<a href="https://docs.djangoproject.com/zh-hans/3.0/ref/models/options/">https://docs.djangoproject.com/zh-hans/3.0/ref/models/options/</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    verbose_name = <span class="string">&quot;名称&quot;</span></span><br><span class="line">    verbose_name_plural = <span class="string">&quot;复数名称&quot;</span></span><br><span class="line">    ordering = [<span class="string">&#x27;排序字段&#x27;</span>]  <span class="comment"># 比如以id倒叙   ordering = [&#x27;-id&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>数据库同步：</p>
<p>一个目录： migrations</p>
<blockquote>
<ul>
<li>里面存放的是makemigrations命令生成的数据库脚本。并且必须要有<code>__init__.py</code>文件夹才可以用</li>
</ul>
</blockquote>
<p>一张数据表，在数据库中: <code>app_migrations</code></p>
<blockquote>
<ul>
<li>app: app名字</li>
<li>name: 脚本的文件名称</li>
<li>applied: 脚本执行的时间</li>
</ul>
</blockquote>
<p>数据库相关的命令：</p>
<blockquote>
<ul>
<li>flush 清空数据库,比较危险</li>
<li>makemigrations 生成数据库脚本</li>
<li>migrate 同步数据库</li>
<li>showmigrations 查看生成数据库的同步脚本</li>
<li>sqlflush 查看清空数据库的脚本</li>
<li>sqlmigrate 查看数据库同步的sql语句</li>
</ul>
</blockquote>
<p>在出现错误的时候可以migrations文件除了<code>__init__.py</code>删除掉，再删除数据库创建一个新数据库。</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - form表单</title>
    <url>/2020/08/03/Django/Django%20-%20form%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<hr>
<p>详情：</p>
<p><a href="https://docs.djangoproject.com/en/3.0/topics/forms/">https://docs.djangoproject.com/en/3.0/topics/forms/</a></p>
<p>两种：</p>
<ul>
<li>django.forms.Form   所有表单的父类</li>
<li>django.forms.ModelForm 和模型类绑定的Form</li>
</ul>
<p>使用Form的父类：</p>
<p>首先在app下创建一个forms.py的表单文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublisherForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">	name = forms.CharField(label=<span class="string">&quot;名称&quot;</span>)</span><br><span class="line">	address = forms.CharField(label=<span class="string">&quot;地址&quot;</span>)</span><br><span class="line">	city = forms.CharField(label=<span class="string">&quot;城市&quot;</span>)</span><br><span class="line">	state_province = forms.CharField(label=<span class="string">&quot;省份&quot;</span>)</span><br><span class="line">	country = forms.CharField(label=<span class="string">&quot;国家&quot;</span>)</span><br><span class="line">	website = forms.URLField(label=<span class="string">&quot;网址&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在views里面：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_pulisher</span>(<span class="params">request</span>):</span></span><br><span class="line">	<span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">		publisher = PublisherForm(request.POST)</span><br><span class="line">		<span class="keyword">if</span> publisher.is_valid():</span><br><span class="line">			name = publisher.cleaned_data[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">			address = publisher.cleaned_data[<span class="string">&quot;address&quot;</span>]</span><br><span class="line">			city = publisher.cleaned_data[<span class="string">&quot;city&quot;</span>]</span><br><span class="line">			state_province = publisher.cleaned_data[<span class="string">&quot;state_province&quot;</span>]</span><br><span class="line">			country = publisher.cleaned_data[<span class="string">&quot;country&quot;</span>]</span><br><span class="line">			website = publisher.cleaned_data[<span class="string">&quot;website&quot;</span>]</span><br><span class="line">			Publisher.objects.create(</span><br><span class="line">				name=name,</span><br><span class="line">				address=address,</span><br><span class="line">				city=city,</span><br><span class="line">				state_province=state_province,</span><br><span class="line">				country=country,</span><br><span class="line">				website=website,</span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">return</span> HttpResponse(<span class="string">&quot;提交成功&quot;</span>)</span><br><span class="line">	pub_form = PublisherForm()</span><br><span class="line">	<span class="keyword">return</span> render(request, <span class="string">&quot;blog/add.html&quot;</span>, locals())</span><br></pre></td></tr></table></figure>
<p>使用ModelForm</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PushlierModelForm</span>(<span class="params">forms.ModelForm</span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model = Publisher</span><br><span class="line">		exclude = (<span class="string">&quot;id&quot;</span>, )</span><br></pre></td></tr></table></figure>
<p>在view中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_pulisher</span>(<span class="params">request</span>):</span></span><br><span class="line">	<span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">		publisher = PushlierModelForm(request.POST)</span><br><span class="line">		<span class="keyword">if</span> publisher.is_valid():</span><br><span class="line">			publisher.save()</span><br><span class="line">			<span class="keyword">return</span> HttpResponse(<span class="string">&quot;提交成功&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> redirect(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">	pub_form = PushlierModelForm()</span><br><span class="line">	<span class="keyword">return</span> render(request, <span class="string">&quot;blog/add.html&quot;</span>, locals())</span><br></pre></td></tr></table></figure>
<h4 id="表单的验证：">表单的验证：</h4>
<p><a href="https://docs.djangoproject.com/en/3.0/ref/forms/validation/">https://docs.djangoproject.com/en/3.0/ref/forms/validation/</a></p>
<p>三种方式验证表单对象：</p>
<ul>
<li>
<p>表单字段的验证器</p>
</li>
<li>
<p>clean_filedname， 验证字段针对某个字段进行验证</p>
</li>
<li>
<p>表单clean方法，针对整个表单进行验证</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - URLS配置</title>
    <url>/2020/08/03/Django/Django%20-%20urls%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr>
<p>在进行url配置中，可以直接在<code>setting -- urls</code>进行配置，也可以在应用下创建urls.py然后再进行配置。直接在urls配置，直接导入<code>app/views</code>的函数就可以了。</p>
<p>在<code>project/urls</code>导入include函数，然后再<code>app/urls</code>中进行配置。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;blog.urls&#x27;</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>app/urls</code>中进行配置。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, view.indexm, name=<span class="string">&#x27;blog-home&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>注意，这里urlpatter是一个列表，所以需要进行添加逗号，进行分割。</p>
<p>在path函数中，第一个表示逻辑request请求，第二个是模板渲染，第三个是模板的<code>url</code>标签使用</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - views配置</title>
    <url>/2020/08/03/Django/Django%20-%20views%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr>
<p>views.py是业务的请求和处理文件。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811072935.png" alt=""></p>
<p>在views模块中，request参数是一个HttpRequest的一个请求。可以使用isinstance()函数查看是否为request是否为HttpRequest的一个子类</p>
<h4 id="Request对象">Request对象</h4>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811072949.png" alt=""></p>
<p>结果为True。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073005.png" alt=""></p>
<p>详情见官方文档：<a href="https://docs.djangoproject.com/en/3.0/ref/request-response/">https://docs.djangoproject.com/en/3.0/ref/request-response/</a></p>
<p>常见的HttpRequst请求：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">path</td>
<td style="text-align:left">Request请求的路径</td>
</tr>
<tr>
<td style="text-align:left">method</td>
<td style="text-align:left">Request请求的方法</td>
</tr>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">包含所有给定HTTP GET参数的类字典对象</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">包含所有给定HTTP POST参数的类字典对象</td>
</tr>
<tr>
<td style="text-align:left">COOKIES</td>
<td style="text-align:left">包含所有cookie的字典。键和值是字符串。</td>
</tr>
<tr>
<td style="text-align:left">user</td>
<td style="text-align:left">用户的验证</td>
</tr>
</tbody>
</table>
<p>GET是在游览器地址中进行传递。POST不会在游览器中传递，但是，对应的GET和POST方法都是一个<code>QueryDict objects  </code></p>
<p>比如在游览器器的地址中输入 ?name=12345</p>
<p>在对应的request中，GET为一个字典序列，所以可以通过字典方式输出name的具体值。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073023.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073033.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073042.png" alt=""></p>
<p>够着一个POST表单：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073057.png" alt=""></p>
<p>输出POST结果就是</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073113.png" alt=""></p>
<p>get是url游览器地址提交，post不会出现在游览器中。这里get提交name=”123“ ，key是name， post提交，name=”key“，这里的值是”key“</p>
<h4 id="Response对象">Response对象</h4>
<p>可以直接使用HttpResponse进行一个直接的内容返回。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073125.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073134.png" alt=""></p>
<p>这里的render函数就是一个HttpResponse的一个子类的方法实现。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073144.png" alt=""></p>
<p>render第一个为Request请求，第二个为渲染的模板，第三个为content内容，用于<code>模板标签</code>的使用。</p>
<p>在render传入content内容的时候，可以使用locals的方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;blog/index.html&quot;</span>, local())</span><br></pre></td></tr></table></figure>
<p>此外还有一个方法，redirect,也是一个HttpResponse的实现，是直接进行网页的跳转。</p>
<p>这样就会直接跳转到百度。</p>
<p>同理，也可以直接跳转到本地设置的路径。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073153.png" alt=""></p>
<p>但是不能跳转到当前路径，不然就会进行死循环跳转。</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - 搜索与分页器</title>
    <url>/2020/08/03/Django/Django%20-%20%E5%88%86%E9%A1%B5%E5%99%A8%E4%B8%8E%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>在Django中进行搜索，利用Django自带的Q 查询。</p>
<h2 id="配置models">配置models</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookManager</span>(<span class="params">models.Manager</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, query=None</span>):</span></span><br><span class="line">        qs = self.get_queryset()</span><br><span class="line">        <span class="comment"># 这里需要查询的类型</span></span><br><span class="line">        <span class="keyword">if</span> query <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            or_lookup = (Q(title__icontains=query) |</span><br><span class="line">                         Q(content__icontains=query)</span><br><span class="line">                        )</span><br><span class="line">            qs = qs.filter(or_lookup).distinct() <span class="comment"># distinct() is often necessary with Q lookups</span></span><br><span class="line">        <span class="keyword">return</span> qs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    date_posted = models.DateTimeField(default=timezone.now)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    publisher = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    url = models.URLField()</span><br><span class="line"></span><br><span class="line">    objects = BookManager()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br></pre></td></tr></table></figure>
<h2 id="配置views">配置views</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> ListView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchView</span>(<span class="params">ListView</span>):</span></span><br><span class="line">    <span class="comment"># 配置你的模板</span></span><br><span class="line">    template_name = <span class="string">&#x27;search.html&#x27;</span></span><br><span class="line">    paginate_by = <span class="number">30</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_data</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        context = super().get_context_data(*args, **kwargs)</span><br><span class="line">        context[<span class="string">&#x27;count&#x27;</span>] = self.count <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">        context[<span class="string">&#x27;query&#x27;</span>] = self.request.GET.get(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> context</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span>(<span class="params">self</span>):</span></span><br><span class="line">        request = self.request</span><br><span class="line">        query = request.GET.get(<span class="string">&#x27;q&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> query <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            results = Book.objects.search(query)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># combine querysets</span></span><br><span class="line">            queryset_chain = chain(</span><br><span class="line">                results,</span><br><span class="line">            )</span><br><span class="line">            qs = sorted(queryset_chain,</span><br><span class="line">                        key=<span class="keyword">lambda</span> instance: instance.pk,</span><br><span class="line">                        reverse=<span class="literal">True</span>)</span><br><span class="line">            self.count = len(qs)  <span class="comment"># since qs is actually a list</span></span><br><span class="line">            <span class="keyword">return</span> qs</span><br><span class="line">        <span class="keyword">return</span> Book.objects.none()  <span class="comment"># just an empty queryset as default</span></span><br></pre></td></tr></table></figure>
<h2 id="配置urls">配置urls</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    …………</span><br><span class="line">    path(<span class="string">&#x27;search/&#x27;</span>, views.SearchView.as_view(), name=<span class="string">&#x27;search&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="配置html文件">配置html文件</h2>
<p>搜索表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;navbar-form navbar-left&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        &#123;% csrf_token %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;popover&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; request.GET.q &#125;&#125;&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入你感兴趣的图书或者作者……&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>&gt;</span>搜 索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内容显示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% for object in object_list %&#125;</span><br><span class="line">    # 这是是搜索内容object</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>分页器在搜索的时候不能直接是page=1之类的， 需要加上<code>&amp;q=&#123;&#123; request.GET.q &#125;&#125;&#123;% endif %&#125;</code>。</p>
<p>分页器：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% if is_paginated %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if page_obj.has_previous %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-info mb-4&quot;</span> <span class="attr">href</span>=<span class="string">&quot;?page=1&#123;% if request.GET.q %&#125;&amp;q=&#123;&#123; request.GET.q &#125;&#125;&#123;% endif %&#125;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-info mb-4&quot;</span> <span class="attr">href</span>=<span class="string">&quot;?page=&#123;&#123; page_obj.previous_page_number &#125;&#125;&#123;% if request.GET.q %&#125;&amp;q=&#123;&#123; request.GET.q &#125;&#125;&#123;% endif %&#125;&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% for num in page_obj.paginator.page_range %&#125;</span><br><span class="line">    &#123;% if page_obj.number == num %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info mb-4&quot;</span> <span class="attr">href</span>=<span class="string">&quot;?page=&#123;&#123; num &#125;&#125;&#123;% if request.GET.q %&#125;&amp;q=&#123;&#123; request.GET.q &#125;&#125;&#123;% endif %&#125;&quot;</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    &#123;% elif num &gt; page_obj.number|add:&#x27;-3&#x27; and num <span class="tag">&lt; <span class="attr">page_obj.number</span>|<span class="attr">add:</span>&#x27;<span class="attr">3</span>&#x27; %&#125;</span></span><br><span class="line">      &lt;a class=&quot;btn btn-outline-info mb-4&quot; href=&quot;?page=&#123;&#123; num &#125;&#125;&#123;% if request.GET.q %&#125;&amp;q=&#123;&#123; request.GET.q &#125;&#125;&#123;% endif %&#125;&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if page_obj.has_next %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-info mb-4&quot;</span> <span class="attr">href</span>=<span class="string">&quot;?page=&#123;&#123; page_obj.next_page_number &#125;&#125;&#123;% if request.GET.q %&#125;&amp;q=&#123;&#123; request.GET.q &#125;&#125;&#123;% endif %&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-info mb-4&quot;</span> <span class="attr">href</span>=<span class="string">&quot;?page=&#123;&#123; page_obj.paginator.num_pages &#125;&#125;&#123;% if request.GET.q %&#125;&amp;q=&#123;&#123; request.GET.q &#125;&#125;&#123;% endif %&#125;&quot;</span>&gt;</span>页尾<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - 安装Mysq数据库</title>
    <url>/2020/08/03/Django/Django%20-%20%E5%AE%89%E8%A3%85MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<hr>
<h4 id="使用homebrew安装MySQL">使用homebrew安装MySQL</h4>
<p>博客：<a href="https://juejin.im/post/5cc2a52ce51d456e7079f27f">https://juejin.im/post/5cc2a52ce51d456e7079f27f</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install mysql</span><br><span class="line"></span><br><span class="line">mysql_secure_installation  <span class="comment"># 配置密码</span></span><br><span class="line">mysql -uroot  <span class="comment"># 启动服务</span></span><br><span class="line">mysql.server start <span class="comment"># 启动mysql服务</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>查看 mysql 初始的密码策略， 输入语句<code>SHOW VARIABLES LIKE 'validate_password%';</code>进行查看</p>
</li>
<li>
<p>首先需要设置密码的验证强度等级，设置 <code>validate_password.policy</code>的全局参数为 LOW 即可，输入设值语句<code>SET GLOBAL validate_password.policy=LOW;</code> 进行设值</p>
</li>
<li>
<p>当前密码长度为8，如果不介意的话就不用修改了，按照通用的来讲，设置为6位的密码，设置<code>validate_password_length</code>的全局参数为6即可，输入设值语句<code>SET GLOBAL validate_password.length=6;</code>进行设值</p>
</li>
<li>
<p>现在可以为MySQL设置简单密码了，只要满足六位的长度即可，输入修改语句<code>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';</code>可以看到修改成功，表示密码策略修改成功了！！！（此时不能使用mysql_secure_installation去设置密码啦！）</p>
</li>
</ol>
<p>或者，通过mysql_secure_installation  # 配置密码</p>
<p>之后并不能通过Navicat直接连接服务器。但是可以通过:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>登录mysql，之后通过<code>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';</code>命令，这样就可以用Navicat直接连接服务了。</p>
<p>此外还有一些命令：</p>
<p><code>show global variables like 'port';</code>  展示端口</p>
<p><code>STATUS</code>  当前服务器信息</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - 创建第一个网页</title>
    <url>/2020/08/03/Django/Django%20-%20%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<hr>
<p>首先创建blog_project 项目，然后创建一个名为blog的app</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">django-admin startproject blog_project</span><br><span class="line">python manage.py startapp blog</span><br></pre></td></tr></table></figure>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073225.png" alt=""></p>
<p>目录结构：</p>
<p><a href="http://manage.py">manage.py</a> 命令行工具脚本</p>
<p>blog_project  (project):</p>
<blockquote>
<ul>
<li><strong>init</strong>.py 表示该项目为一个包</li>
<li><a href="http://setting.py">setting.py</a> 项目配置</li>
<li><a href="http://url.py">url.py</a> url配置</li>
<li><a href="http://wsgi.py">wsgi.py</a> wsgi配置，在部署的时候需要</li>
</ul>
</blockquote>
<p>blog (app):</p>
<blockquote>
<ul>
<li><strong>init</strong>.py 表示该应用为一个包</li>
<li>migrations 数据库同步目录</li>
<li><a href="http://admin.py">admin.py</a> admin配置，管理配置</li>
<li><a href="http://models.py">models.py</a> 模型代码,对应映射数据库</li>
<li><a href="http://test.py">test.py</a>  单元测试</li>
<li><a href="http://view.py">view.py</a> 业务逻辑</li>
</ul>
</blockquote>
<p>首先在view中创建一个http response，服务器有请求，就一定需要一个响应。<br>
<img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073241.png" alt=""></p>
<p>这里服务器响应的为一个文本“Hello world”</p>
<p>然后在<code>project -- urls</code>中配置url。<br>
<img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073252.png" alt=""></p>
<p>然后运行项目。登录游览器<a href="http://localhost:8000">http://localhost:8000</a>进行访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<h4 id="接下来创建模板">接下来创建模板</h4>
<p>在创建模板的时候，一定要在<code>project -- setting</code> 里面安装app。这样才能搜索到templates和static 文件夹</p>
<p>首先创建templates， 在blog应用中，创建templates文件夹，然后在文件夹下面创建blog文件夹，然后在blog文件在下面再创建index.html文件。这样方便管理。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073303.png" alt=""></p>
<p>在view中在进行配置。利用render函数进行模板的渲染，传入的参数为<code>request</code>请求。响应为<code>render(request, &quot;blog/index.html&quot;, content)</code></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073312.png" alt=""></p>
<p>在index.html文件编写如下。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073320.png" alt=""></p>
<p>需要注意的是render函数中的content是以字典的形式进行传入的。{user: user_list} 这templates中，利用模板标签for循环，user对应的就是传入的字典user名字。for循环进行的就是遍历user_list里面的数据。 这里的模板标签不能随便加空格，在花括号和%之前加入空格是不合法的。不会被Django识别。</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - 数据库配置和ORM机制</title>
    <url>/2020/08/03/Django/Django%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E5%92%8CORM%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>首先在setting里面会配置好数据库的信息：这里默认的是使用sqlite3的数据库</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python支持这些引擎，详情见： <a href="https://docs.djangoproject.com/en/3.0/ref/settings/#databases">https://docs.djangoproject.com/en/3.0/ref/settings/#databases</a></p>
<ul>
<li>‘django.db.backends.postgresql’</li>
<li>‘django.db.backends.mysql’</li>
<li>‘django.db.backends.sqlite3’</li>
<li>‘django.db.backends.oracle’</li>
</ul>
<h4 id="切换成MySQL数据库">切换成MySQL数据库</h4>
<p>首先需要安装MySQL的python驱动库。这里使用mysqlclient</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure>
<p>然后需要在setting里面更改数据库引擎和配置。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;blog_project&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;demo9090&#x27;</span>,</span><br><span class="line">        <span class="comment">#  这里可选配置</span></span><br><span class="line">        <span class="comment"># &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,</span></span><br><span class="line">        <span class="comment"># &#x27;PORT&#x27;: &#x27;5432&#x27;,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后利用Navicat连接数据库，之后创建数据库。<br>
<img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150514.png" alt=""></p>
<p>接下来进行表单同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>同步表单后就可以看到表单数据了。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150525.png" alt=""></p>
<h4 id="ORM机制">ORM机制</h4>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150552.png" alt=""></p>
<p>对象关系映射(英语:Object Relational Mapping,简称ORM)，用于实现面向对象编程语言里不同类型系统的数据之间的转换.换句说，就是用面向对象的方式去操作数据库的创建表，增加、修改、删除、查询等操作</p>
<p>比如： 可以在QuerySet中调用query属性</p>
<p>在<code>views.py</code>中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    user_list = User.Objects.all()</span><br><span class="line">    print(user_list.query)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&quot;blog/index.html&quot;</span>, &#123;<span class="string">&quot;user&quot;</span>: user_list&#125;)</span><br></pre></td></tr></table></figure>
<p>这样会得到一套sql语句，然后再Navicat中查询一下query(询问)</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150607.png" alt=""></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`auth_user`</span>.<span class="string">`id`</span>, <span class="string">`auth_user`</span>.<span class="string">`password`</span>, <span class="string">`auth_user`</span>.<span class="string">`last_login`</span>, <span class="string">`auth_user`</span>.<span class="string">`is_superuser`</span>, <span class="string">`auth_user`</span>.<span class="string">`username`</span>, <span class="string">`auth_user`</span>.<span class="string">`first_name`</span>, <span class="string">`auth_user`</span>.<span class="string">`last_name`</span>, <span class="string">`auth_user`</span>.<span class="string">`email`</span>, <span class="string">`auth_user`</span>.<span class="string">`is_staff`</span>, <span class="string">`auth_user`</span>.<span class="string">`is_active`</span>, <span class="string">`auth_user`</span>.<span class="string">`date_joined`</span> <span class="keyword">FROM</span> <span class="string">`auth_user`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询结果</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200803150626.png" alt=""></p>
<p>ORM优缺点</p>
<ol>
<li>
<p>ORM使得我们通过数据库交互变的简单易行，并且完全不用考虑该死的SQL语句，快速开发，由此而来</p>
</li>
<li>
<p>可以避免一些你搜程序猿写sql语句带来的性能和效率问题</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>
<p>性能有所牺牲。不过现在的各种ORM框架都在尝试使用各种方法来减轻这个问题(LazyLoad，Cache)，效果还是很显著的</p>
</li>
<li>
<p>对于个别复杂查询，ORM仍然力不从心。为了 解决这个问题，ORM框架一般也提供了直接原生sql的方式</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - 虚拟环境配置</title>
    <url>/2020/08/03/Django/Django%20-%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>利用虚拟环境可以进行项目的独立开发，不会进行相互的形象，在Python中创建虚拟环境可以利用Anaconda进行创建，也可以利用virtualenv进行创建。</p>
<h4 id="Anaconda进行创建">Anaconda进行创建</h4>
<p>conda常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda list           查看包</span><br><span class="line">conda env list       查看环境</span><br><span class="line">conda update conda   更新conda</span><br></pre></td></tr></table></figure>
<p>创建一个虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n xxx python=3.7    python设置可以下调</span><br></pre></td></tr></table></figure>
<p>激活虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate xxx</span><br></pre></td></tr></table></figure>
<p>对虚拟环境中安装额外的包:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -n your_env_name [package]</span><br></pre></td></tr></table></figure>
<p>关闭虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<p>删除虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda remove -n your_env_name(虚拟环境名称) --all</span><br><span class="line">conda remove --name your_env_name  package_name  <span class="comment"># 删除环境中的某个包</span></span><br></pre></td></tr></table></figure>
<h4 id="virtualenv进行创建">virtualenv进行创建</h4>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>
<p>然后创建一个文件夹、进入文件夹<br>
创建虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv xxx</span><br></pre></td></tr></table></figure>
<p>启动环境变量:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> xxx/bin/activate</span><br></pre></td></tr></table></figure>
<p>退出虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p>删除虚拟环境，直接删除文件就行.</p>
<hr>
<p>接下来安装启动虚拟环境，然后安装Django</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install Django==3.0.8</span><br></pre></td></tr></table></figure>
<p>然后创建Django项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">django-admin startproject xxxx(项目名)</span><br></pre></td></tr></table></figure>
<p>在Pycharm中添加项目，创建项目之后。在Pycharm中打开项目，然后preferences中找到项目的环境变量设置。选择Conda<br>
<img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073432.png" alt=""></p>
<p>到这里环境变量就配置结束了。如果需要删除项目，直接删除项目就可以。</p>
<p>Pycharm运行，快捷键设置。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073442.png" alt=""></p>
<hr>
<p>常用的manage命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py runserver  <span class="comment"># 运行服务器</span></span><br><span class="line">python manage.py createsuperuser <span class="comment"># 创建超级账户</span></span><br><span class="line">python manage.py makemigrations  <span class="comment"># 创建生成数据库表单</span></span><br><span class="line">python manage.py migrate  <span class="comment"># 同步数据库</span></span><br><span class="line">python manage.py shell</span><br><span class="line">....</span><br><span class="line">python manage.py <span class="built_in">help</span></span><br><span class="line">python manage.py <span class="built_in">help</span> xxx(命令)</span><br></pre></td></tr></table></figure>
<p>利用NaviCat进行数据库的链接。在链接数据库之前，需要进行数据库的同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations  <span class="comment"># 创建生成数据库表单</span></span><br><span class="line">python manage.py migrate  <span class="comment"># 同步数据库</span></span><br></pre></td></tr></table></figure>
<p>然后利用账户和创建的超级用户进行链接：<br>
<img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073454.png" alt=""></p>
<p>链接后就可以查看到表单的详情：<br>
<img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200811073505.png" alt=""></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - 部署到Linux服务器</title>
    <url>/2020/08/03/Django/Django%20-%20%E9%83%A8%E7%BD%B2%E5%88%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>首先进行文件的打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
<p>然后创建服务器， 进行ssh登录。</p>
<h4 id="在服务器操作如下：">在服务器操作如下：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进行服务器软件更新</span></span><br><span class="line">apt update &amp;&amp; apt upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置服务器的名称为Django-server</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname django-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看hostname</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line">nano /etc/hosts</span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">youripaddress django-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加账户</span></span><br><span class="line">adduser &lt;username&gt;</span><br><span class="line">adduser &lt;username&gt; sudo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后使用newuser 进行ssh 连接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地电脑上操作</span></span><br><span class="line"><span class="comment"># 创建一个ssh目录, -p 为允许创建目录和子目录, ~ 表示为主目录下面</span></span><br><span class="line">mkdir -p ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地进行生成ssh key</span></span><br><span class="line">ssh-keygen -b 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地的为id_ra 服务器为pub</span></span><br><span class="line"><span class="comment"># 传输pub key 到服务器</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub username@ip:~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后给.ssh 文件夹写入权限， 给.ssh 文件夹读取权限</span></span><br><span class="line">sudo chmod 700 ~/.ssh/</span><br><span class="line">sudo chmod 600 ~/.ssh/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后进行ssh, 不用密码连接</span></span><br><span class="line">ssh username@ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在服务器上修改sshd_config</span></span><br><span class="line"><span class="comment"># passwordauthorize No</span></span><br><span class="line"><span class="comment"># rootlogin No</span></span><br><span class="line">nano /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载ssh服务</span></span><br><span class="line">sudo systemctl restart sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装防火墙</span></span><br><span class="line">sudo apt install ufw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改防火墙</span></span><br><span class="line">sudo ufw default allow outgoing</span><br><span class="line">sudo ufw default deny incoming</span><br><span class="line">sudo ufw allow ssh</span><br><span class="line">sudo ufw allow 8000 <span class="comment"># django</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line">sudo ufw status <span class="comment"># ufw status</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把requirements.txt 复制到工程文件下面, 然后传到服务器根目录下面</span></span><br><span class="line">scp -r project_name username@ipaddress:~/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装python3-pip</span></span><br><span class="line">sudo apt install python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装env</span></span><br><span class="line">sudo apt install python3-venv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建env</span></span><br><span class="line">python3 -m venv project_name/venv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动env</span></span><br><span class="line"><span class="built_in">cd</span> project_name</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装环境</span></span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Django -- settings -- ALLOWRD_HOSTED = [&#x27;ip_address&#x27;]</span></span><br><span class="line"><span class="comment"># 设置STATIC_ROOT = os.path.join(BASE_DIR, &#x27;static&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行项目集合</span></span><br><span class="line">python manage.py collectstatic</span><br><span class="line">python manage.py runserver 0.0.0.0:8000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Apache2</span></span><br><span class="line">sudo apt install apache2</span><br><span class="line">sudo apt install libapache2-mod-wsgi-py3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入Apache2设置</span></span><br><span class="line"><span class="built_in">cd</span> /etc/apache2/sites-available/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Django.conf</span></span><br><span class="line">sudo cp 000-default.conf django_project.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑django_project.conf</span></span><br><span class="line">sudo nano django_project.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在vitrulHost中添加下面代码</span></span><br><span class="line"></span><br><span class="line">Alias /static /home/<span class="string">&quot;&lt;username&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>/static</span><br><span class="line">&lt;Directory /home/<span class="string">&quot;&lt;usernaem&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>/static&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Alias /media /home/<span class="string">&quot;&lt;username&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>/media</span><br><span class="line">&lt;Directory /home/<span class="string">&quot;&lt;usernaem&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>/media&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Directory /home/<span class="string">&quot;&lt;usernaem&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>&gt;</span><br><span class="line">    &lt;Files wsgi.py&gt;</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;/Files&gt;</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">WSGIScriptAlias / /home/<span class="string">&quot;&lt;userneme&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>/wsgi.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WSGIDaemonProcess django_app python-path=/home/<span class="string">&quot;&lt;username&gt;&quot;</span>/<span class="string">&quot;&lt;django_project&gt;&quot;</span>/venv</span><br><span class="line"></span><br><span class="line">WSGIProcessGroup django_app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Django设置</span></span><br><span class="line">sudo a2ensite django_project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭000-default.conf</span></span><br><span class="line">sudo a2dissite 000-default.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Apache2服务器权限</span></span><br><span class="line">sudo chown :www-data django_project/db.sqlite3</span><br><span class="line">sudo chmod 755 django_project/db.sqlite3</span><br><span class="line">sudo chown :www-data django_project</span><br><span class="line">sudo chown -R :www-data django_project/media</span><br><span class="line">sudo chmod -R 755 django_project/media</span><br><span class="line">sudo chmod 775 django_project/</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置隐藏服务器密码</span></span><br><span class="line">sudo touch /etc/config.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># nano /etc/config.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在django_project -- settings 中</span></span><br><span class="line"><span class="comment"># import json</span></span><br><span class="line"><span class="comment"># with open(&quot;etc/config.json&quot;) as config_file:</span></span><br><span class="line"><span class="comment">#    config = json.load(config_file)</span></span><br><span class="line"><span class="comment"># SECRET_KEY = config[&#x27;SECRET_KEY&#x27;]</span></span><br><span class="line"><span class="comment"># DEBUG = Flase</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除8000端口</span></span><br><span class="line">sudo ufw delete allow 8000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加http/tcp</span></span><br><span class="line">sudo ufw allow http/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务器</span></span><br><span class="line">sudo server apache2 restart</span><br><span class="line">systemctl reload apache2</span><br></pre></td></tr></table></figure>
<p><code>/etc/config.json</code>文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;SECRET_KEY&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EMAIL_USER&quot;</span>: <span class="string">&quot;xxx@163.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EMAIL_PASS&quot;</span>: <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>django_project -- setings.py</code>中进行如下配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;/etc/config.json&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    conf = json.load(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECRET_KEY = conf[<span class="string">&#x27;SECRTY_KEY&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>或者在部署的时候进行根目录部署</p>
<p>然后输出日志器。在根目录下面进行创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:<span class="number">80</span>&gt;</span><br><span class="line"></span><br><span class="line">    ServerAdmin webmaster@localhost</span><br><span class="line">    DocumentRoot /<span class="keyword">var</span>/www/html</span><br><span class="line"></span><br><span class="line">    ErrorLog /site/logs/error.log</span><br><span class="line">    CustomLog /site/access.log combine</span><br><span class="line"></span><br><span class="line">    alias /<span class="keyword">static</span> /blog_project/<span class="keyword">static</span></span><br><span class="line">    &lt;Directory /blog_project/<span class="keyword">static</span>&gt;</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Directory /blog_project/blog_project&gt;</span><br><span class="line">        &lt;Files wsgi.py&gt;</span><br><span class="line">            Require all granted</span><br><span class="line">        &lt;/Files&gt;</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">    WSGIDaemonProcess blog_project python-path=<span class="regexp">/blog_project python-home=/</span>blog_project/venv</span><br><span class="line">    WSGIProcessGroup blog_project</span><br><span class="line">    WSGIScriptAlias / <span class="regexp">/blog_project/</span>blog_project/wsgi.py</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>解决图片上传有中文问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;apache2&#x2F;envvars</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> LANG=<span class="string">&#x27;zh_CN.UTF-8&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&#x27;zh_CN.UTF-8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LANG=<span class="string">&#x27;en_US.UTF-8&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">&#x27;en_US.UTF-8&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python - 解决pip安装时速度慢的问题</title>
    <url>/2020/08/03/Python/pip_slow/</url>
    <content><![CDATA[<p>线路问题，修改国内源</p>
<h2 id="国内源：">国内源：</h2>
<p>新版ubuntu要求使用https源，要注意。</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p>
<p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p>
<p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></p>
<p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
<p>临时使用：<br>
可以在使用<code>pip</code>的时候加参数<code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<p>例如：<code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider</code>，这样就会从清华这边的镜像去安装pyspider库。</p>
<p>永久修改，一劳永逸：<br>
Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)</p>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>
<p>windows下，直接在user目录中创建一个pip目录，如：<code>C:\Users\xx\pip</code>，新建文件pip.ini。内容同上。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>其它 - Mac 在当前文件夹打开terminal</title>
    <url>/2020/08/03/%E5%85%B6%E4%BB%96/Mac%20%E5%9C%A8%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%93%E5%BC%80terminal/</url>
    <content><![CDATA[<p><code>系统偏好设置</code> - <code>键盘</code> - <code>快捷键</code> - <code>服务</code> 勾选如下</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200820092320.png" alt=""></p>
<p>然后在文件夹中选择右键：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200820092643.png" alt=""></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>其它 - Mac 如何清除缓存</title>
    <url>/2020/08/03/%E5%85%B6%E4%BB%96/Mac%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>有时候系统缓存比较多，造成空间的浪费。所以需要定期的清除系统缓存。</p>
<p>鼠标先点击桌面，执行命令<code>Command+Shift+G</code>前往文件夹，然后方框输入<code>~/Library/Caches/</code></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200820092201.png" alt=""></p>
<p>然后删除不需要的缓存就行, 此外还有清空回收站就OK了。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>其它 - Markdown希腊字母查表</title>
    <url>/2020/08/03/%E5%85%B6%E4%BB%96/Markdown%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">字母</th>
<th style="text-align:left">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\alpha$</td>
<td style="text-align:left"><code>$\alpha$</code></td>
</tr>
<tr>
<td style="text-align:center">$\beta$</td>
<td style="text-align:left"><code>$\beta$</code></td>
</tr>
<tr>
<td style="text-align:center">$\gamma$</td>
<td style="text-align:left"><code>$\gamma$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Gamma$</td>
<td style="text-align:left"><code>$\Gamma$</code></td>
</tr>
<tr>
<td style="text-align:center">$\delta$</td>
<td style="text-align:left"><code>$\delta$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Delta$</td>
<td style="text-align:left"><code>$\Delta$</code></td>
</tr>
<tr>
<td style="text-align:center">$\epsilon$</td>
<td style="text-align:left"><code>$\epsilon$</code></td>
</tr>
<tr>
<td style="text-align:center">$\varepsilon$</td>
<td style="text-align:left"><code>$\varepsilon$</code></td>
</tr>
<tr>
<td style="text-align:center">$\zeta$</td>
<td style="text-align:left"><code>$\zeta$</code></td>
</tr>
<tr>
<td style="text-align:center">$\eta$</td>
<td style="text-align:left"><code>$\eta$</code></td>
</tr>
<tr>
<td style="text-align:center">$\theta$</td>
<td style="text-align:left"><code>$\theta$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Theta$</td>
<td style="text-align:left"><code>$\Theta$</code></td>
</tr>
<tr>
<td style="text-align:center">$\vartheta$</td>
<td style="text-align:left"><code>$\vartheta$</code></td>
</tr>
<tr>
<td style="text-align:center">$\iota$</td>
<td style="text-align:left"><code>$\iota$</code></td>
</tr>
<tr>
<td style="text-align:center">$\kappa$</td>
<td style="text-align:left"><code>$\kappa$</code></td>
</tr>
<tr>
<td style="text-align:center">$\lambda$</td>
<td style="text-align:left"><code>$\lambda$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Lambda$</td>
<td style="text-align:left"><code>$\Lambda$</code></td>
</tr>
<tr>
<td style="text-align:center">$\mu$</td>
<td style="text-align:left"><code>$\mu$</code></td>
</tr>
<tr>
<td style="text-align:center">$\nu$</td>
<td style="text-align:left"><code>$\nu$</code></td>
</tr>
<tr>
<td style="text-align:center">$\xi$</td>
<td style="text-align:left"><code>$\xi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Xi$</td>
<td style="text-align:left"><code>$\Xi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\pi$</td>
<td style="text-align:left"><code>$\pi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Pi$</td>
<td style="text-align:left"><code>$\Pi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\varpi$</td>
<td style="text-align:left"><code>$\varpi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\rho$</td>
<td style="text-align:left"><code>$\rho$</code></td>
</tr>
<tr>
<td style="text-align:center">$\varrho$</td>
<td style="text-align:left"><code>$\varrho$</code></td>
</tr>
<tr>
<td style="text-align:center">$\sigma$</td>
<td style="text-align:left"><code>$\sigma$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Sigma$</td>
<td style="text-align:left"><code>$\Sigma$</code></td>
</tr>
<tr>
<td style="text-align:center">$\varsigma$</td>
<td style="text-align:left"><code>$\varsigma$</code></td>
</tr>
<tr>
<td style="text-align:center">$\tau$</td>
<td style="text-align:left"><code>$\tau$</code></td>
</tr>
<tr>
<td style="text-align:center">$\upsilon$</td>
<td style="text-align:left"><code>$\upsilon$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Upsilon$</td>
<td style="text-align:left"><code>$\Upsilon$</code></td>
</tr>
<tr>
<td style="text-align:center">$\phi$</td>
<td style="text-align:left"><code>$\phi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Phi$</td>
<td style="text-align:left"><code>$\Phi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\varphi$</td>
<td style="text-align:left"><code>$\varphi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\chi$</td>
<td style="text-align:left"><code>$\chi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\psi$</td>
<td style="text-align:left"><code>$\psi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Psi$</td>
<td style="text-align:left"><code>$\Psi$</code></td>
</tr>
<tr>
<td style="text-align:center">$\Omega$</td>
<td style="text-align:left"><code>$\Omega$</code></td>
</tr>
<tr>
<td style="text-align:center">$\omega$</td>
<td style="text-align:left"><code>$\omega$</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx - Jupyter + Nginx</title>
    <url>/2020/08/01/%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Jupyter/</url>
    <content><![CDATA[<p>在服务器上部署Jupyter，使Jupyter成为一个云笔记本</p>
<hr>
<h2 id="创建账户并安装Jupyter-和-Nginx">创建账户并安装Jupyter 和 Nginx</h2>
<p>首先创建一个账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser ubuntu</span><br><span class="line"><span class="comment"># 添加到管理组</span></span><br><span class="line">adduser ubuntu sudo</span><br></pre></td></tr></table></figure>
<p>创建脚本，运行一下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sudo apt-get update -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install build-essential libssl-dev libpq-dev libcurl4-gnutls-dev libexpat1-dev gettext unzip -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install supervisor -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install python3-pip python3-dev python3-venv -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install nano -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install git -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install nginx curl -y</span><br><span class="line"></span><br><span class="line">sudo apt-get install ufw -y</span><br><span class="line"></span><br><span class="line">sudo ufw allow <span class="string">&#x27;Nginx Full&#x27;</span></span><br><span class="line"></span><br><span class="line">sudo ufw allow ssh</span><br><span class="line"></span><br><span class="line">sudo python3 -m pip install jupyter</span><br><span class="line"></span><br><span class="line">sudo service supervisor start</span><br><span class="line"></span><br><span class="line">sudo apt autoremove -y</span><br></pre></td></tr></table></figure>
<p>通过ip访问主机： <a href="http://47.100.78.128">http://47.100.78.128</a> 访问你的主机。应该会出现一个Nginx的初始界面。</p>
<hr>
<h2 id="进行Jupyter-配置">进行Jupyter 配置</h2>
<p>配置Jupyter config：</p>
<p>生成配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成哈希密码</span></span><br><span class="line">ipython -c <span class="string">&quot;from notebook.auth import passwd; passwd()&quot;</span></span><br></pre></td></tr></table></figure>
<p>更新配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /home/ubuntu/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>
<p>添加配置到config里面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c = get_config()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kernel config</span></span><br><span class="line">c.IPKernelApp.pylab = <span class="string">&#x27;inline&#x27;</span>  <span class="comment"># if you want plotting support always in your notebook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Notebook config</span></span><br><span class="line"></span><br><span class="line">c.NotebookApp.allow_origin = <span class="string">&#x27;http://107.21.189.212&#x27;</span> <span class="comment"># put your public IP Address here</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">c.NotebookApp.allow_remote_access = True</span><br><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line">c.NotebookApp.password = u<span class="string">&#x27;sha1:45e47cb75d9e:49dc0b09f4e671485b6113c1e2c5a13d7d37fa78&#x27;</span></span><br><span class="line">c.NotebookApp.port = 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># For https &amp; letsencrypt later</span></span><br><span class="line"><span class="comment"># c.NotebookApp.certfile = u&#x27;/your/cert/path/cert.pem&#x27;</span></span><br><span class="line"><span class="comment"># c.NotebookApp.keyfile = u&#x27;/your/cert/path/privkey.pem&#x27;</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Nginx设置">Nginx设置</h2>
<p>这里安装的是Nginx，使用Apache2原理一样只是麻烦点。创建<code>jupyter_config</code>配置文件,名称可以任意：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/jupyter_app.conf</span><br></pre></td></tr></table></figure>
<p>配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name jupyter_notebook;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        include proxy_params;</span><br><span class="line">        proxy_pass http://localhost:8888;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_buffering off;</span><br><span class="line">        proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        proxy_set_header Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">        proxy_read_timeout 86400;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您打算使用自定义域，请替换<code>server_name jupyter_notebook;</code>为<code>server_name your_custom_domain.com;</code></p>
<p>此外还需要在<code>jupyter_notebook_config.py</code>中更该为<code>c.NotebookApp.allow_origin = '*'</code></p>
<p>启动配置文件。并重启服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /etc/nginx/sites-available/jupyter_app.conf /etc/nginx/sites-enabled/jupyter_app.conf</span><br><span class="line"></span><br><span class="line">sudo rm /etc/nginx/sites-enabled/default</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="创建后台运行Jupyter">创建后台运行Jupyter</h2>
<p>创建配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/supervisor/conf.d/my_jupyter.conf</span><br></pre></td></tr></table></figure>
<p>配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[program:my_jupyter]</span><br><span class="line">user=ubuntu</span><br><span class="line">directory=/home/ubuntu</span><br><span class="line"><span class="built_in">command</span>=jupyter notebook</span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">stdout_logfile=/var/<span class="built_in">log</span>/my_jupyter/stdout.log</span><br><span class="line">stderr_logfile=/var/<span class="built_in">log</span>/my_jupyter/stderr.log</span><br></pre></td></tr></table></figure>
<p>启动配置程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建日志</span><br><span class="line">sudo mkdir &#x2F;var&#x2F;log&#x2F;my_jupyter</span><br><span class="line"></span><br><span class="line"># 启动配置</span><br><span class="line">sudo supervisorctl reread</span><br><span class="line">sudo supervisorctl update</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="其他">其他</h2>
<ol>
<li>
<p>此方法还可以使用JupyterLab和JupyterHub</p>
</li>
<li>
<p>其他想不起来了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 - 01 人工神经网络 VS 生物神经网络</title>
    <url>/2020/08/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20-%2001_%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CVS%E7%94%9F%E7%89%A9%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<hr>
<h2 id="人工神经网络-VS-生物神经网络">&gt; 人工神经网络 VS 生物神经网络</h2>
<h3 id="Artificial-Neural-Nets-Vs-Neural-Nets">Artificial Neural Nets Vs Neural Nets</h3>
<p>相同与差别：</p>
<ul>
<li>都有神经元</li>
<li>但是人工神经网络是固定不变的。</li>
</ul>
<h3 id="在训练过程中">在训练过程中</h3>
<ul>
<li>生物神经网络会产生新的神经元，通过新的神经元来记忆信息</li>
<li>人工神经网络不会产生新的神经原，人工神经网络是预先准备大量正确数据，通过神经原的输出加工与正确数据进行对比，计算出loss值，在神经元中进行反向传递，从而修正神经元的强度，达到训练的目的。</li>
<li>即给定一个输入信号，和正确信息。输出信号通过神经元，到输出信号， 输出信号对比正确信息，计算loss梯度值， loss再进行反向传递，修改神经元强度，即修改神经元对正确信息有没有贡献</li>
</ul>
<h2 id="什么是神经网络（机器学习）">&gt; 什么是神经网络（机器学习）</h2>
<h3 id="人工神经网络是一种数学模型">人工神经网络是一种数学模型</h3>
<ul>
<li>神经网络是一种运算模型，由大量的节点（或称神经元）之间相互联接构成</li>
<li>每个节点代表一种特定的输出函数，称为激励函数（activation function）</li>
</ul>
<h2 id="神经网络梯度下降">&gt; 神经网络梯度下降</h2>
<h3 id="Gradient-Descent-In-Neural-Nets">Gradient Descent In Neural Nets</h3>
<ul>
<li>Optimization: Newton’s method, Least Squares method, Gradient Descent</li>
<li>Cost = (predicted - real)^2 = (Wx - y)^2 = (Wx - 0)^2</li>
</ul>
<h2 id="激励函数">&gt; 激励函数</h2>
<h3 id="Activation-Function">Activation Function</h3>
<ul>
<li>Linear and NonLinear</li>
<li>Y= Wx --&gt; y = AF(Wx)</li>
<li>AF : relu, sigmoid, tanh</li>
<li>当神经层只有两三层不是很多的时候任意的激励函数都行</li>
<li>卷积神经网络推荐的是relu</li>
</ul>
<h3 id="激励函数的使用">激励函数的使用</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># fake data</span></span><br><span class="line">x = torch.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">200</span>)</span><br><span class="line">x = Variable(x)</span><br><span class="line">x_np = x.data.numpy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y_relu = torch.relu(x).data.numpy()</span><br><span class="line">y_sigmoid = torch.sigmoid(x).data.numpy()</span><br><span class="line">y_tanh = torch.tanh(x).data.numpy()</span><br><span class="line">y_softplus = F.softplus(x).data.numpy()</span><br><span class="line"><span class="comment"># y_sofymax = F.softmax()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>, figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(x_np, y_relu, c=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">plt.ylim((<span class="number">-1</span>, <span class="number">5</span>))</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(x_np, y_sigmoid, c=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line">plt.ylim((<span class="number">-0.2</span>, <span class="number">1.2</span>))</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.plot(x_np, y_tanh, c=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;tanh&#x27;</span>)</span><br><span class="line">plt.ylim((<span class="number">-1.2</span>, <span class="number">1.2</span>))</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot(x_np, y_softplus, c=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;softplus&#x27;</span>)</span><br><span class="line">plt.ylim((<span class="number">-0.2</span>, <span class="number">6</span>))</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812085756.png" alt=""></p>
<ul>
<li>激励函数的使用：torch.tanh, torch.relu, torch.sigmoid, torch.nn.functional.softplus, torch.nn.functional.softmax</li>
</ul>
<h2 id="Regression-回归">&gt; Regression 回归</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fake data 创建假数据</span></span><br><span class="line"></span><br><span class="line">x = torch.unsqueeze(torch.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">100</span>), dim=<span class="number">1</span>)</span><br><span class="line">y = x.pow(<span class="number">2</span>) + <span class="number">0.2</span> * torch.rand(x.size())</span><br><span class="line"></span><br><span class="line">x, y = Variable(x), Variable(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.scatter(x.data.numpy(), y.data.numpy())</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_feature, n_hidden, n_output</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hidden = torch.nn.Linear(n_feature, n_hidden) <span class="comment"># 层数的输入和输出</span></span><br><span class="line">        self.predict = torch.nn.Linear(n_hidden, n_output)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = torch.relu(self.hidden(x))</span><br><span class="line">        x = self.predict(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># print(net)</span></span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">loss_func = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    pre = net(x)</span><br><span class="line"></span><br><span class="line">    loss = loss_func(pre, y)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># plot and show learning process</span></span><br><span class="line">        plt.cla()</span><br><span class="line">        plt.scatter(x.data.numpy(), y.data.numpy())</span><br><span class="line">        plt.plot(x.data.numpy(), pre.data.numpy(), <span class="string">&#x27;r-&#x27;</span>, lw=<span class="number">5</span>)</span><br><span class="line">        plt.text(<span class="number">0.5</span>, <span class="number">0</span>, <span class="string">&#x27;Loss=%.4f&#x27;</span> % loss.data.numpy(), fontdict=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;color&#x27;</span>:  <span class="string">&#x27;red&#x27;</span>&#125;)</span><br><span class="line">        plt.pause(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812085819.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812085828.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812085833.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812085842.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812085848.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812085856.png" alt=""></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812085906.png" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 - 02 Regression 回归</title>
    <url>/2020/08/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20-%2002_Regression%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h3 id="拟合曲线">拟合曲线</h3>
<ul>
<li>创建一条曲线，利用神经网络进行拟合</li>
<li>数据的创建</li>
<li>torch.nn.Module 的基本使用</li>
<li>如何训练，如何进行反向传递</li>
<li>有哪些optimization 优化器</li>
<li>有哪些激励函数</li>
<li>有哪些loss function 偏差函数</li>
<li>loss function 如何进行使用的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># generator fake data</span></span><br><span class="line">x = torch.unsqueeze(torch.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">100</span>), <span class="number">1</span>) <span class="comment"># 为什么增加纬度 ?</span></span><br><span class="line"><span class="comment"># y = x ** 2 + torch.rand(x.size())</span></span><br><span class="line">y = x ** <span class="number">2</span> + <span class="number">0.2</span> * torch.rand(x.size())</span><br><span class="line"><span class="comment"># y = x.pow(2) + 0.2 * torch.rand(x.size())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.scatter(x.data.numpy(), y.data.numpy())</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_future, out_future, pre_out</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hidden = torch.nn.Linear(in_future, out_future)</span><br><span class="line">        self.predict = torch.nn.Linear(out_future, pre_out)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = torch.relu(self.hidden(x))</span><br><span class="line">        x = self.predict(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">loss_func = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    predict = net(x)</span><br><span class="line"></span><br><span class="line">    loss = loss_func(predict, y)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># plot and show learning process</span></span><br><span class="line">        plt.cla()</span><br><span class="line">        plt.scatter(x.data.numpy(), y.data.numpy())</span><br><span class="line">        plt.plot(x.data.numpy(), pre.data.numpy(), <span class="string">&#x27;r-&#x27;</span>, lw=<span class="number">5</span>)</span><br><span class="line">        plt.text(<span class="number">0.5</span>, <span class="number">0</span>, <span class="string">&#x27;Loss=%.4f&#x27;</span> % loss.data.numpy(), fontdict=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;color&#x27;</span>:  <span class="string">&#x27;red&#x27;</span>&#125;)</span><br><span class="line">        plt.pause(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812091526.png" alt=""></p>
<h3 id="几大模块">几大模块</h3>
<p>neural network神经网络模块</p>
<ul>
<li>torch.nn.Module 继承，神经网络module</li>
<li>torch.nn.Linear 线性神经层数</li>
<li>torch.nn.MSELoss 计算prediction 和 real 的差值，进行反向传递</li>
</ul>
<p>optimizer 优化模块</p>
<ul>
<li>torch.optim.SGD(net.parameters(), lr=0.1)</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 - 03 FizzBuzz Game</title>
    <url>/2020/08/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20-%2003_FizzBizz%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>FizzBuzz是一个简单的小游戏。游戏规则如下：从1开始往上数数，当遇到3的倍数的时候，说fizz，当遇到5的倍数，说buzz，当遇到15的倍数，就说fizzbuzz，其他情况下则正常数数。</p>
<p>我们可以写一个简单的小程序来决定要返回正常数值还是fizz, buzz 或者 fizzbuzz。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NUM_DIGITES = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fizz_buzz_encode</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">15</span> == <span class="number">0</span>:  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">5</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">3</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:              <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fizz_buzz_decode</span>(<span class="params">num, index</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [str(num), <span class="string">&#x27;fizz&#x27;</span>, <span class="string">&#x27;buzz&#x27;</span>, <span class="string">&#x27;fizzbuzz&#x27;</span>][index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># test game</span></span><br><span class="line"><span class="comment"># for i in range(1,16):</span></span><br><span class="line"><span class="comment">#     print(fizz_buzz_decode(i, fizz_buzz_encode(i)), end=&#x27; &#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们首先定义模型的输入与输出(训练数据)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_bin_encode</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.array([num &gt;&gt; d &amp; <span class="number">1</span> <span class="keyword">for</span> d <span class="keyword">in</span> range(NUM_DIGITES)])</span><br><span class="line"></span><br><span class="line">trX = torch.Tensor([num_bin_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>, <span class="number">2</span> ** NUM_DIGITES)])</span><br><span class="line">trY = torch.LongTensor([fizz_buzz_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>, <span class="number">2</span> ** NUM_DIGITES)])</span><br></pre></td></tr></table></figure>
<p>然后我们用PyTorch定义模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NUM_HIDDEN = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">    nn.Linear(NUM_DIGITES, NUM_HIDDEN),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(NUM_HIDDEN, <span class="number">4</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>为了让我们的模型学会FizzBuzz这个游戏，我们需要定义一个损失函数，和一个优化算法。</li>
<li>这个优化算法会不断优化（降低）损失函数，使得模型的在该任务上取得尽可能低的损失值。</li>
<li>损失值低往往表示我们的模型表现好，损失值高表示我们的模型表现差。</li>
<li>由于FizzBuzz游戏本质上是一个分类问题，我们选用Cross Entropyy Loss函数。</li>
<li>优化函数我们选用Stochastic Gradient Descent。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.05</span>)</span><br></pre></td></tr></table></figure>
<p>以下是模型的训练代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BATCH_SIZE = <span class="number">128</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">0</span>, len(trX), BATCH_SIZE):</span><br><span class="line">        end = start + BATCH_SIZE</span><br><span class="line">        batchX = trX[start:end]</span><br><span class="line">        batchY = trY[start:end]</span><br><span class="line"></span><br><span class="line">        y_pre = model(batchX)</span><br><span class="line">        loss = loss_fn(y_pre, batchY)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    loss = loss_fn(model(trX), trY).item()</span><br><span class="line">    print(<span class="string">&#x27;epoch:&#x27;</span>, epoch, <span class="string">&#x27;loss:&#x27;</span>, loss)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>epoch: 0 loss: 1.1909565925598145
…………
epoch: 9999 loss: 0.0071606868878006935
</code></pre>
<p>最后我们用训练好的模型尝试在1到100这些数字上玩FizzBuzz游戏</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testX = torch.Tensor([num_bin_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)])</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    testY = model(testX)</span><br><span class="line">predictions = zip(range(<span class="number">1</span>, <span class="number">101</span>), testY.max(<span class="number">1</span>)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print([fizz_buzz_decode(num, index) <span class="keyword">for</span> num, index <span class="keyword">in</span> predictions])</span><br></pre></td></tr></table></figure>
<pre><code>['1', '2', 'fizz', 'buzz', 'buzz', 'fizz', '7', '8', 'fizz', 'buzz', '11', 'fizz', '13', '14', 'fizzbuzz', '16', '17', 'fizz', '19', 'buzz', 'fizz', '22', '23', 'fizz', '25', 'buzz', 'fizz', '28', '29', 'fizzbuzz', '31', '32', 'fizz', '34', 'buzz', 'fizz', '37', '38', 'fizz', 'buzz', '41', '42', '43', '44', 'fizzbuzz', '46', '47', 'fizz', '49', 'buzz', 'fizz', '52', '53', 'fizz', 'buzz', '56', 'fizz', '58', '59', 'fizzbuzz', '61', '62', 'fizz', 'buzz', 'buzz', 'fizz', '67', 'buzz', 'fizz', 'buzz', '71', 'fizz', '73', '74', 'fizzbuzz', '76', '77', 'fizz', '79', 'buzz', 'fizz', '82', '83', 'fizz', 'buzz', '86', '87', '88', '89', 'fizzbuzz', '91', '92', 'fizz', '94', 'buzz', 'fizz', '97', '98', 'fizz', 'buzz']
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算正确数目, 因为true是int的子类型，true == 1 false == 0</span></span><br><span class="line">print(np.sum(testY.max(<span class="number">1</span>)[<span class="number">1</span>].numpy() == np.array([fizz_buzz_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)])))</span><br></pre></td></tr></table></figure>
<pre><code>93
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testY.max(<span class="number">1</span>)[<span class="number">1</span>].numpy() == np.array([fizz_buzz_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>)])</span><br></pre></td></tr></table></figure>
<pre><code>array([ True,  True,  True, False,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True, False, False,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True, False,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
       False,  True,  True,  True, False,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True, False,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True])
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 - Mac 使用terminal写入img镜像</title>
    <url>/2020/08/03/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%20-%20Mac%20%E4%BD%BF%E7%94%A8terminal%E5%86%99%E5%85%A5img%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>首先对U盘进行格式化，利用SD Card Formatter,这款格式化工具可以从SD官网下载。</p>
<h2 id="操作步骤">操作步骤</h2>
<p>1.进入目录</p>
<p>插入要写入的sd卡，进入Mac上存放img镜像文件的目录，比如我的就是放在Desktop上的raspberryiso文件夹，那么terminal的命令就是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/desktop/rasiberryiso</span><br></pre></td></tr></table></figure>
<p>2.列出目前系统上的所有磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure>
<p>在terminal里找到你要写入的磁盘的编号.</p>
<p>3.推出此磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (&lt;disk#&gt;换成你要写入的磁盘编号）</span></span><br><span class="line">diskutil unmountDisk /dev/&lt;disk<span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure>
<p>4.用dd命令将树莓派系统镜像写入SD卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd bs=1m <span class="keyword">if</span>=&lt;your image file name&gt;.img of=/dev/&lt;disk<span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure>
<p>输入这个命令后系统会提示你输入密码，此时输入你电脑账户的密码即可。然后开始写入。如果没有载入新的命令行，说明正在写入，这时候就需要耐心等待，有事需要几个小时，根据你文件大小和U盘传输速率来定。</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 01背包</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%2001%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/2/">https://www.acwing.com/problem/content/2/</a></p>
<p>推荐视频讲解： <a href="https://www.acwing.com/video/322/">https://www.acwing.com/video/322/</a></p>
<p>题目描述：</p>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p>
<p>第 i 件物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>
输出最大价值。</p>
<hr>
<p>根据闫氏DP法：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210531.png" alt=""></p>
<p>状态计算就是状态方程，所以： $ f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])$   这里$j - v[i] &gt;= 0 $</p>
<p>所以伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">0</span> to n:</span><br><span class="line">    <span class="keyword">for</span> j &lt;- <span class="number">0</span> to m:</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">if</span> v[i] &lt;= j:</span><br><span class="line">            f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>具体Python代码实现如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1010</span></span><br><span class="line">dp = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">v = [<span class="number">0</span>]*N</span><br><span class="line">w = [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n, m = map(int, input().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        v[i], w[i] = map(int, input().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[i]:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - v[i]] + w[i])</span><br><span class="line"></span><br><span class="line">    print(dp[n][m])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>根据dp表格所推出来的数据如下， 行表示物品i， 列表示背包容量v</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>4</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>4</td>
<td>6</td>
<td>6</td>
<td>8</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>4</td>
<td>6</td>
<td>6</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>由状态转移方程可以看出，f[i][j]都是来自于第i-1层的数据，这时就可以使用可以利用一层空间进行状态的记录，我们只需要从大到小的枚举， 那么$f[j - v[i]]$的状态就是$f[i - 1][j - v[i]]$的状态。</p>
<p>伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to n:</span><br><span class="line">    <span class="keyword">for</span> j &lt;- v to v[i]:</span><br><span class="line">        f[j] = max(f[j], f[j - v[i] + w[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为使用一维状态，那么f[j] = f[i - 1][j]保持着上次的数据，这时就只需要枚举到v[i]。但是在二维背包中，f[i][j]默认是0，每层的背包都需要跟新，所以背包容量j从0开始枚举到m。</p>
<p>具体Python代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1010</span></span><br><span class="line">dp, v, w = [<span class="number">0</span>]*N, [<span class="number">0</span>]*N, [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n, m = map(int, input().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        v[i], w[i] = map(int, input().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m, v[i] - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j] = max(dp[j], dp[j - v[i]] + w[i])</span><br><span class="line"></span><br><span class="line">    print(dp[m])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 分组背包问题</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/9/">https://www.acwing.com/problem/content/9/</a></p>
<p>推荐视频讲解： <a href="https://www.acwing.com/video/341/">https://www.acwing.com/video/341/</a></p>
<p>有 N 组物品和一个容量是 V 的背包。</p>
<p>每组物品有若干个，同一组内的物品最多只能选一个。<br>
每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 i 是组号，j 是组内编号。</p>
<p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p>
<p>输出最大价值。</p>
<hr>
<p>闫氏DP法：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210547.png" alt=""></p>
<p>所以状态方程就是：</p>
<p>$f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i][n]] + w[i][n])$</p>
<p>C++ 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> s[N], v[N][N], w[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i]; j++) <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python实现：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">N = <span class="number">110</span></span><br><span class="line">f, s = [<span class="number">0</span>]*N, [<span class="number">0</span>]*N</span><br><span class="line">v = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">w = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n, m = map(int, input().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        s[i] = int(input())</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(s[i]):</span><br><span class="line">            v[i][j], w[i][j] = map(int, input().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(s[i]):</span><br><span class="line">                <span class="keyword">if</span> v[i][k] &lt;= j:</span><br><span class="line">                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k])</span><br><span class="line"></span><br><span class="line">    print(f[m])</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 多重背包</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/4/">https://www.acwing.com/problem/content/4/</a></p>
<p>推荐视频讲解： <a href="https://www.acwing.com/video/325/">https://www.acwing.com/video/325/</a></p>
<p>题目描述：</p>
<p>有 N 种物品和一个容量是 V 的背包。</p>
<p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>
输出最大价值。</p>
<p>PS: 完全背包和01背包的区别就是01背包只能选一件，完全背包可以选无数件</p>
<hr>
<p>闫氏DP法：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210741.png" alt=""></p>
<p>PS: 多重背包问题和完全背包类似，这里是指从k件物品变成到了s[i]件物品。</p>
<p>所以伪代码同完全背包的最初版本：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to n:</span><br><span class="line">    <span class="keyword">for</span> j &lt;- <span class="number">1</span> to m:</span><br><span class="line">        <span class="keyword">for</span> k &lt;- <span class="number">0</span> to s[i] <span class="keyword">and</span> k * v[i] &lt;= j:</span><br><span class="line">            f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 实现如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1010</span></span><br><span class="line">dp, v, w, s = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)], [<span class="number">0</span>]*N, [<span class="number">0</span>]*N, [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n, m = map(int, input().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        v[i], w[i], s[i] = map(int, input().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k &lt;= s[i] <span class="keyword">and</span> k * v[i] &lt;= j:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - k * v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(dp[n][m])</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>这代题的数据范围是 N &lt;= 100, 所以用这样的暴力解法能过。</p>
<p>在下一道题 N &lt;= 1000，这样的数据范围下，代码会超时。</p>
<p>所以会有一个二进制值优化：</p>
<p>比如一个数可以由2的倍数组成：</p>
<p>$2^0 = 1, 2^1 = 2, 2^2 = 4, 2^3 = 8…$</p>
<p>比如数字7  = 1 + 2 + 3 = $2^0 + 2^1 + 2^2$</p>
<p>所以可以把s[i]最多分成$log s[i] + 1$份数， 然后再做01背包</p>
<p>比如s[i] = 7, 那么就可以分成$2^0 + 2^1 + 2^2$，然后在做01背包，那么选择的时候就可以选择:<br>
1， 2， 4 那么最大就是7可以被选<br>
1, 2 那么3就可以被选<br>
1, 4 那么5就可以被选<br>
2, 4 那么6就可以被选<br>
1 那么1 就可以被选<br>
2 那么2 就可以被选<br>
3 那么3 就可以被选</p>
<p>这样就不用再一个一个从i = 0 枚举到s[i],此外还有个细节需要注意就是二进制$2^n &lt;= s[i]$,当$2^n &lt; s[i]$的时候需要把$s[i] - 2^n$剩余的也放入背包中</p>
<p>Python实现如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 应为数据范围是N &lt;= 1000, M &lt;= 2000 所以做01背包的时候就是 N * M * log(M) ~= 20000多, 数据N = 25000 就不会超掉</span></span><br><span class="line">N = <span class="number">25000</span></span><br><span class="line">dp = [<span class="number">0</span>]*N</span><br><span class="line">v = [<span class="number">0</span>]*N</span><br><span class="line">w = [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n, m = map(int, input().split())</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        a, b, c = map(int, input().split())</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> temp &lt;= c:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            v[cnt] = temp * a</span><br><span class="line">            w[cnt] = temp * b</span><br><span class="line">            c -= temp</span><br><span class="line">            temp *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            v[cnt] = c * a</span><br><span class="line">            w[cnt] = c * b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cnt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m, v[i] - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[j] = max(dp[j], dp[j - v[i]] + w[i])</span><br><span class="line"></span><br><span class="line">    print(dp[m])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 动态规划基础</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<p>动态规划是数据结构和算法中比较难的一部分，我学动态规划也是走走停停，从来没有完整学完过动态规划。所以我打算这一次完完整整的学完动态规划，并通过写题解的方式记录下来。</p>
<p>接下来是正文。</p>
<p>动态规划是什么？又是一个非常高大上的一个名词，百度百科解释如下：</p>
<p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。</p>
<p>解释很专业，但是我是没太明白说的是个啥</p>
<p>学动态规划讲的比较详细的是《算法导论》，建议参看。</p>
<p>动态规划简单讲就是一个利用<code>空间换取时间</code>降低时间复杂度的一个技术。</p>
<p>讲动态规划一定离不开斐波那契数列问题。斐波那契数列的关系式： $f(n) = f(n - 1) + fib(n - 2), f(n) = 1, n &lt; 2$</p>
<p>这样的一个关系式在动态规划叫做<code>状态转移方程</code>，就是状态n有n-1和n-2转移过来的。首先写一个暴力解时间复杂度$O(2^n)$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(fib(i), end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>1 1 2 3 5 8 13 21 34 55
</code></pre>
<p>当n达到40左右的时候，程序就会非常慢了。有兴趣的可以试一下，因为这是指数级时间复杂度。</p>
<p>画下递归树以fib(8)为例：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210611.png" alt=""></p>
<p>在算fib(8)的时候，计算了1次fib(7), 2次fib(6), 3次fib(5)， 4次fib(4)。也就有一个现象，就是<code>重复计算</code>。</p>
<p>如何避免重复计算就可以把时间复杂度降低了，很直接的一个想法就是把每次计算的值存到一个地方，下次如果需要用的时候，在直接取出来，就可以避免重复计算了。就是很直白的一个空间换时间的一个想法，也就是<code>动态规划(DP)</code>。</p>
<p>这里我用哈希表来存放计算的数值，用数组或者其他的数据结构也行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibMemo</span>(<span class="params">n, memo=&#123;&#125;</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = fibMemo(n - <span class="number">1</span>) + fibMemo(n - <span class="number">2</span>)</span><br><span class="line">        memo[n] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fibMemo(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<pre><code>573147844013817084101
</code></pre>
<p>这样可以很快的算出斐波那契数。因为哈希表每次的寻址时间复杂度是$O(1)$， 所以，整个算法的时间复杂度就是$O(n)$。</p>
<p>到这里，已经是动态规划了，它有个名字叫做<code>自上而下</code>版本，是递归的形式，但是往往需要改成非递归版本。因为非递归版本使用空间更小，递归版本容易发生爆栈。</p>
<p>至于怎么改非递归版本，这里有个小套路，如果写了递归版本，那么可以根据递归版本套路改，或者，直接递归方程式写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibUnrecur</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 这里属于判特，n 不能小于0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 这里用数组，dp也叫表格法</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(n + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># n &lt; 2， fib(n) = 1</span></span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 然后n &gt;= 2，从2开始递推</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fibUnrecur(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<pre><code>573147844013817084101
</code></pre>
<p>这里的dp[0], dp[1]属于递归的base case， 然后从2 ~ n进行递推，只是把递归的写法fib(n) = fib(n - 1) + fib(n - 2)变换成了，dp[i] = dp[i - 1] + dp[i - 2]。这个可以很直观的看出来时间复杂度是$O(n)$， 空间复杂度是$O(n)$。</p>
<p>到这里，其实基本上已经结束了，但是这道题还有个小小的空间优化，由<code>状态转移方程</code>可以看出，n的状态只和n - 1和n - 2有关系，这里就可以进行空间的优化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibFinal</span>(<span class="params">n</span>):</span></span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        a, b  = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fibFinal(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<pre><code>573147844013817084101
</code></pre>
<p>这里的时间复杂度是$O(n)$的， 空间复杂度是$O(1)$。到这里就是动态规划的全部过程。</p>
<p>细心的你可能已经发现了，动态规划最难的部分不在于敲代码，在于写<code>状态方程式</code>。如果你能写出状态方程式，那么改动态规划还是比较套路化的。当然有些个别题例外，大部分都是考状态转移方程，至于怎么写出状态转移方程，套路就是，多刷题，多练，当然也有大佬总结出一些常见的动态规划的模板比如比较出名的是dd大牛的《背包九讲》，群里有上传文件。</p>
<p>总结一下：</p>
<ul>
<li>写出状态转移方程， 或者递归表达式。(两个东西是一样的，写出一个一定能写出另一个)</li>
<li>改动态规划，如果能够优化空间复杂度就优化空间复杂度。</li>
</ul>
<hr>
<p>推荐几道练手题：</p>
<p>类似于斐波那契数列 - <a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/">三步问题</a><br>
推dp表格 - <a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a><br>
01背包问题 - <a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a><br>
完全背包问题- <a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 完全背包</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/3/">https://www.acwing.com/problem/content/3/</a></p>
<p>推荐视频讲解： <a href="https://www.acwing.com/video/324/">https://www.acwing.com/video/324/</a></p>
<p>题目描述：</p>
<p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p>
<p>第 i 种物品的体积是 vi，价值是 wi。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>
输出最大价值。</p>
<p>PS: 完全背包和01背包的区别就是01背包只能选一件，完全背包可以选无数件</p>
<hr>
<p>闫氏DP法：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210759.png" alt=""></p>
<p>状态计算就是状态方程，所以： $ f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i], f[i - 1][j - 2<em>v[i] + 2</em>w[i],…<br>
, f[i - 1][j - k*v[i] + k * w[i]) $   这里$j - K * v[i] &gt;= 0$</p>
<p>伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to n:</span><br><span class="line">    <span class="keyword">for</span> j &lt;- <span class="number">1</span> to m:</span><br><span class="line">        <span class="keyword">for</span> k &lt;- <span class="number">0</span> to j - k*v[i] &gt; <span class="number">0</span>:</span><br><span class="line">            f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 实现如下(超时)：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1010</span></span><br><span class="line">dp, v, w = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)], [<span class="number">0</span>]*N, [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n, m = map(int, input().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        v[i], w[i] = map(int, input().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> k * v[i] &lt;= j:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - k * v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(dp[n][m])</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>在此进行优化一下：<br>
$f[i][j] = max(f[i][j], f[i- 1][j – v] + w, f[i - 1][j - 2v] + 2w, … f[i - 1][j - kv] + kw)$<br>
$f[i][j - v] = max(f[i][j - v], f[i- 1][j – 2v] + w, f[i - 1][j - 3v] + 2w, … f[i - 1][j - kv] + (k - 1)w)$</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210812.png" alt=""></p>
<p>这里的运算是取最大值, 所以红框里面部分只相差一个w[i] 所以状态方程就可以写成为:<br>
$f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i])$</p>
<p>01背包状态方程式：<br>
$f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])$</p>
<p>不同点在于01背包是i - 1， 而完全背包是i</p>
<p>所以伪代码如下(类似于01背包)：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to n:</span><br><span class="line">    <span class="keyword">for</span> j &lt;- <span class="number">1</span> to m:</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">if</span> v[i] &lt;= j:</span><br><span class="line">            <span class="comment"># 只是这里变成了i</span></span><br><span class="line">            f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]</span><br></pre></td></tr></table></figure>
<p>Python实现：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">N = <span class="number">1010</span></span><br><span class="line">dp = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">w = [<span class="number">0</span>]*N</span><br><span class="line">v = [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n, m = map(int, input().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        v[i], w[i] = map(int, input().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> v[i] &lt;= j:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i])</span><br><span class="line"></span><br><span class="line">    print(dp[n][m])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>同样也可以优化为一维，由于是f[i][j]需要的是f[i][j - v[i]]的状态，所以，只需要在使用前计算更新计算过第i层就行了。只要从小到大开始枚举，那么所在层数的j - v[i]是更新过了的，也就是第i层</p>
<p>伪代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to n:</span><br><span class="line">    <span class="keyword">for</span> j &lt;- v[i] to m:</span><br><span class="line">        f[j] = max(f[j], f[j - v[i]] + w[i]</span><br></pre></td></tr></table></figure>
<p>代码和01背包的写法非常类似，只是循环一个是从前，一个是从后。</p>
<p>Python实现</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">N = <span class="number">1010</span></span><br><span class="line">dp, w, v = [<span class="number">0</span>]*N, [<span class="number">0</span>]*N, [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    n, m = map(int, input().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        v[i], w[i] = map(int, input().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(v[i], m + <span class="number">1</span>):  <span class="comment"># 只是这里和01代码有所不同</span></span><br><span class="line">           dp[j] = max(dp[j], dp[j - v[i]] + w[i])</span><br><span class="line"></span><br><span class="line">    print(dp[m])</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 数字三角形</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<hr>
<p>题目来源： <a href="https://www.acwing.com/problem/content/900/">https://www.acwing.com/problem/content/900/</a></p>
<p>题目描述：</p>
<p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大</p>
<p>这道题非常注重边界条件，比如矩阵的初始化，利用维度的选择比较有技巧，还有把不规则的三角形放在一个矩阵中这个技巧比较重要。</p>
<p>所以在三角形中，左边是行i，右边是列j，所以构造成一个三角矩阵，然后再通过求集合的方式，求出状态转移方程。</p>
<p>这里的属性取max，然后又正数有负数，有0，所以初始化的时候都初始化为-INF，这里非常重要。</p>
<p>所以状态转移方程就是：</p>
<p>$f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]$</p>
<p>伪代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> j &lt;- <span class="number">1</span> to i</span><br><span class="line">        f[i][j] = max(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + a[i][j]</span><br><span class="line"></span><br><span class="line">res = -inf</span><br><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to n</span><br><span class="line">    res = max(res, f[n][i]</span><br></pre></td></tr></table></figure>
<p>C++实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N], f[N][N] = &#123;-INF&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j++)</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用逆推的方式，这种方式不用考虑边界条件， 所以状态方程就变成：</p>
<p>$f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]$</p>
<p>伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt;- n - <span class="number">1</span> to <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j &lt;- <span class="number">1</span> to i</span><br><span class="line">        f[i][j] = max(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j + <span class="number">1</span>]) + a[i][j]</span><br><span class="line"></span><br><span class="line">res = f[<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>C++逆推实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        f[n][i] = a[n][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>应为f[i][j] 都是由f[i + 1]转移过来的，所以也可以使用一维表示, 使用滚动数组。二维改成一维并不会有特别大的提升。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        f[i] = a[n][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 整数划分</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/902/">https://www.acwing.com/problem/content/902/</a></p>
<p>描述：</p>
<p>一个正整数n可以表示成若干个正整数之和，形如：$n=n1+n2+…+nk$，其中$n1≥n2≥…≥nk,k≥1$。</p>
<p>我们将这样的一种表示称为正整数n的一种划分。</p>
<p>现在给定一个正整数n，请你求出n共有多少种不同的划分方法。</p>
<p><code>由于答案可能很大，输出结果请对109+7取模。</code></p>
<hr>
<h3 id="方法一、-完全背包">方法一、 完全背包</h3>
<p>可以类似于完全背包问题进行处理，可以变成物品i = 0 ~ n， j = n；这样进行处理。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210853.png" alt=""></p>
<p>dp分析</p>
<p>状态表示f[i][j]:</p>
<blockquote>
<ul>
<li>集合： f[i][j] 表示，选i个物品，恰好背包装满容量为j。</li>
<li>属性： Count</li>
</ul>
</blockquote>
<p>状态计算</p>
<blockquote>
<ul>
<li>第i件可以选择0， 1， 2， 3， 4 …， s件，恰好装满</li>
<li>所以就等于集合的相加。</li>
<li>状态转移方程就可以写为： $f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2i]…f[i - 1][j - si]$</li>
</ul>
</blockquote>
<p>状态转移方程优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f[i][j] = f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - i] + f[i - <span class="number">1</span>][j - <span class="number">2</span>i]....f[i - <span class="number">1</span>][j - si]</span><br><span class="line">f[i][j - i] =           f[i - <span class="number">1</span>][j - i] + f[i - <span class="number">1</span>][j - <span class="number">2</span>i]....f[i - <span class="number">1</span>][j - si]</span><br></pre></td></tr></table></figure>
<p>所以，状态转移方程就可以写为 $f[i][j] = f[i - 1][j] + f[i][j - i]$</p>
<p>同样可以优化为1维度。这里只需要从小到大进行循环就行。   $f[j] = f[j] + f[j - i]$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法二、计数DP分析">方法二、计数DP分析</h3>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210903.png" alt=""></p>
<p>计数dp分析：</p>
<p>状态表示f[i][j]:</p>
<blockquote>
<ul>
<li>集合： 表示累加和为i，累加和的长度为j的数</li>
<li>属性： Count</li>
</ul>
</blockquote>
<p>状态计算：</p>
<blockquote>
<ul>
<li>分解为长度等于1和长度大于1两个部分</li>
<li>如果长度等于1，f[i][j] = f[i - 1][j - 1]，f[i - 1][j - 1]长度为1</li>
<li>如果长度大于1，f[i][j] = f[i - j][j] 表示i - j的数的长度为j的值</li>
<li>所以某个数的长度就是： f[n][1] + f[n][2] … f[n][n]</li>
</ul>
</blockquote>
<p>所以状态转移方程： $f[i][j] = f[i - 1][j - 1] + f[i - j][j]$</p>
<p>C++实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = (res + f[n][i]) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 最长上升子序列 II</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%20II/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/description/898/">https://www.acwing.com/problem/content/description/898/</a></p>
<p>描述：</p>
<p>给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。</p>
<hr>
<p>个人觉得思路不算是动态规划，应该算是贪心：</p>
<ul>
<li>如果w[i] &gt; f[cnt] 的，那么直接加入到后面去。</li>
<li>如果w[i] &lt;= f[cnt]， 那么找到一个大于w[i]的数，然后替换掉。(这里的查找使用二分法)。</li>
</ul>
<p>所以时间复杂度就是 $O(nlogn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    f[++cnt] = w[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; f[cnt]) f[++cnt] = w[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>, r = cnt;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid  = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (f[mid] &gt;= w[i]) r  = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[l] = w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 最短编辑距离</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/description/904/">https://www.acwing.com/problem/content/description/904/</a></p>
<p>描述：</p>
<p>给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：</p>
<p>1.删除–将字符串A中的某个字符删除。</p>
<p>2.插入–在字符串A的某个位置插入某个字符。</p>
<p>3.替换–将字符串A中的某个字符替换为另一个字符。</p>
<p>现在请你求出，将A变为B至少需要进行多少次操作。</p>
<hr>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804210934.png" alt=""></p>
<p>dp分析：</p>
<p>分别为两个部分，一个是状态表示，一个是状态计算，</p>
<p>状态表示, f[i][j]：</p>
<blockquote>
<ul>
<li>f[i][j] 表示： 以a[1 ~ i] 变成 b[1 ~ j] 所需要的操作数目</li>
<li>属性： Min</li>
</ul>
</blockquote>
<p>状态计算, 集合划分：</p>
<blockquote>
<ul>
<li>删除：  a[1 ~ i] 比 b[1 ~ j] 长度长，那么删除a[i]后相等，f[i][j] = f[i - 1][j] + 1(操作数)</li>
<li>添加：  a[1 ~ i] 比 b[1 ~ j] 长度短，那么添加a[i]后相等，f[i][j] = f[i][j - 1] + 1(操作数)</li>
<li>修改：  a[i] == a[j] 那么f[i][j] = f[i - 1][j - 1] 否者就是f[i][j] = f[i - 1][j - 1] + 1</li>
</ul>
</blockquote>
<p>所以状态转移方程就是: $f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1] + 1)$</p>
<p>在这里需要进行表格初始化，当stra等于长度等于0的时候变为strb, 以及当strb长度为0的时候stra变成strb。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;m, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化，a = 0，b != 0变为b; a != 0, b = 0变为b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 最长上升子序列</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/description/897/">https://www.acwing.com/problem/content/description/897/</a></p>
<p>题目描述：</p>
<p>给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。</p>
<p>首先要求几个东西，一个是状态状态分析，一个是状态计算。状态分析就是提出一种暴力的解决方式，然后再用DP(表格法)的方式去解决这个问题。</p>
<p>首先是表格的长度，因为中庸存放等长的数组，所以就只用输入长度N的一维数组就可以了，然后把f[i]和w[i]进行联系起来。所以这里就需要表示f[i]的意义了。</p>
<ul>
<li>状态表示</li>
</ul>
<blockquote>
<ul>
<li>集合的划分, f[i]表示： 以w[i]结尾的最长子序列，默认为1</li>
<li>属性 ： max</li>
</ul>
</blockquote>
<ul>
<li>状态计算</li>
</ul>
<blockquote>
<ul>
<li>也就是f[i]的划分，也就是f[i] 的计算。</li>
<li>遍历j &lt;- 1 to i, 如果w[i] &gt; w[j]， 更新f[i] 的值</li>
</ul>
</blockquote>
<p>伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">res = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> j &lt;- <span class="number">1</span> to i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> w[i] &gt; w[j]</span><br><span class="line">            f[i] = max(f[i], f[j] + <span class="number">1</span>)</span><br><span class="line">    res = max(res, f[i])</span><br></pre></td></tr></table></figure>
<p>c++ 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; w[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 最长公共子序列</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/description/899/">https://www.acwing.com/problem/content/description/899/</a></p>
<p>描述：</p>
<p>给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少。</p>
<hr>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804211005.png" alt=""></p>
<p>dp分析：</p>
<p>首先确定状态f[i][j], 因为是两个字符串，所以用f[i][j]两维数组表示比较好(经验)。</p>
<p>dp分析分为： 状态表示，和状态计算。</p>
<p>状态表示：</p>
<blockquote>
<ul>
<li>集合: f[i][j] 表示以a[i]字母结尾，和以b[j]字母结尾的最长公共子序列。</li>
<li>属性：Max</li>
</ul>
</blockquote>
<p>状态计算：</p>
<blockquote>
<p>集合划分：分成4个部分</p>
<ul>
<li>1.不取a[i],b[j]</li>
<li>2.取a[i], b[j]</li>
<li>3.取a[i], 不取b[j]</li>
<li>4.不取a[i], 取b[j];</li>
</ul>
</blockquote>
<p>所以状态方程就是：$f[i][j] = max(f[i - 1][j - 1], f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1)$</p>
<p>但是因为$f[i][j]$表示以$a[i], b[j]$字符结尾的最长子序列，所以$f[i - 1][j] $包含$f[i - 1][j - 1]$的情况，所以状态转移方程就可以只写为：</p>
<p>$f[i][j] = max(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 石子合并</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/284/">https://www.acwing.com/problem/content/284/</a></p>
<p>描述：</p>
<p>设有N堆石子排成一排，其编号为1，2，3，…，N。</p>
<p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24；</p>
<p>如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。</p>
<p>问题是：找出一种合理的方法，使总的代价最小，输出最小代价。</p>
<hr>
<p>首先是因为是相邻的区间进行合并，所以就是一个分界点，分成两个部分，一个部分左边，一部分右边。这样就符合题意的相邻两个部分进行合并，这样只用以2堆，3堆，4堆，一直到长度为n堆进行合并就行了。因为是区间DP问题，所以状态表示为$f[i][j]$。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804211015.png" alt=""></p>
<p>区间dp分析：</p>
<p>状态表示$f[i][j]$</p>
<blockquote>
<ul>
<li>集合： 区间i ~ j 合并所需要的代价</li>
<li>属性： Min</li>
</ul>
</blockquote>
<p>状态计算：</p>
<blockquote>
<ul>
<li>以k为分界点，把区间分成两部分，k可以取值1, 2, 3, 4…, k - 1</li>
<li>合并的代价就是区间的长度的价值</li>
<li>状态转移方程就是： $f[i][j] = min(f[i][k] + f[k + 1][j] + s[j] - s[i - 1]), k = 1, 2, 3, 4…, k - 1$</li>
</ul>
</blockquote>
<p>写区间dp问题，注意就是区间的写法。如何写区间，调整区间。</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">        <span class="comment">// 枚举所有区间长度，从2开始</span></span><br><span class="line">        left = i, right = i + len - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt; right; k++)</span><br><span class="line">            <span class="comment">//状态转移方程</span></span><br><span class="line">            f[left][right] = <span class="built_in">min</span>(f[left][k] + f[k + <span class="number">1</span>][right] + s[right] - s[left - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//答案 区间 1 ~ n</span></span><br><span class="line">f[<span class="number">1</span>][n]</span><br></pre></td></tr></table></figure>
<p>C++实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line">            f[l][r] = <span class="number">1e8</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt; r; k++)</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Python 实现：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">N = <span class="number">310</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># f 表示状态, s表示数据和</span></span><br><span class="line">    f = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    s = [<span class="number">0</span>]*N</span><br><span class="line">    n = int(input())</span><br><span class="line">    <span class="comment"># 写入数据从角标1开始</span></span><br><span class="line">    s[<span class="number">1</span>:] = map(int, input().split())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> len <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> i + len - <span class="number">1</span> &lt;= n:</span><br><span class="line">                l, r = i, i + len - <span class="number">1</span></span><br><span class="line">                f[l][r] = <span class="number">1e8</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(l, r):</span><br><span class="line">                    <span class="comment"># 状态转移方程</span></span><br><span class="line">                    f[l][r] = min(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表示从1 ~ n区间</span></span><br><span class="line">    print(f[<span class="number">1</span>][n])</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 编辑距离</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AE%97%E6%B3%95%20-%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<hr>
<p>来源： <a href="https://www.acwing.com/problem/content/901/">https://www.acwing.com/problem/content/901/</a></p>
<p>描述：</p>
<p>给定n个长度不超过10的字符串以及m次询问，每次询问给出一个字符串和一个操作次数上限。</p>
<p>对于每次询问，请你求出给定的n个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。</p>
<p>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p>
<p>输入格式<br>
第一行包含两个整数n和m。</p>
<p>接下来n行，每行包含一个字符串，表示给定的字符串。</p>
<p>再接下来m行，每行包含一个字符串和一个整数，表示一次询问。</p>
<p>字符串中只包含小写字母，且长度均不超过10。</p>
<hr>
<p>编辑距离是最短编辑距离的应用，只是有些地方时是C++的一些应用，状态方程都是一样的。但是在理一遍，加清思路分析。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804211030.png" alt=""></p>
<p>动态规划，线性dp分析：</p>
<p>状态表示f[i][j]:</p>
<blockquote>
<ul>
<li>集合：表示a[1 ~ i] 变成 b[1 ~ j]所需要的代价</li>
<li>属性： min</li>
</ul>
</blockquote>
<p>状态计算:</p>
<blockquote>
<ul>
<li>添加： 添加之前的是b[j],所以添加之前，需要a[i]和b[j - 1]进行匹配。 所以就是f[i]][j - 1] + 1</li>
<li>删除： 删除之后a[i]和b[j]相等，所以删除后是f[i - 1][j], 那么f[i - 1][j] + 1 就是f[i][j]</li>
<li>修改： a[i - 1]和b[j - 1]都相等，那么看a[i]和b[j]，如果相等 + 0，不等 + 1</li>
</ul>
</blockquote>
<p>所以状态转移方程就是：</p>
<p>$f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1, f[i - 1][j - 1] + 1 / 0 )$</p>
<p>注意就是C++的字符串的一些用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">char</span> w[N][M];</span><br><span class="line"><span class="keyword">int</span> f[M][M];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">(<span class="keyword">char</span> a[], <span class="keyword">char</span> b[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从a + 1, b + 1开始统计a, b两个字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> la = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lb; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lb; j++) &#123;</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[la][lb];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, w[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[M];</span><br><span class="line">    <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, tmp + <span class="number">1</span>, &amp;limit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (edit(w[i], tmp) &lt;= limit) res ++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - Morris遍历</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20Morris%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>Morris遍历是一种神级遍历方式，遍历一颗树做到时间复杂度$O(n)$ 空间复杂度是$O(1)$。基础的思路就是利用叶节点下面的空节点作为返回上级的指针。</p>
<hr>
<p>基本思路：</p>
<ul>
<li>当前节点cur</li>
<li>如果cur没有左孩子，那么直接滑向右孩子</li>
<li>如果cur有左孩子， 那么左孩子最右边的节点mostRight</li>
<li>如果mostRight.right指向，nil让其指向cur， cur 向左移动</li>
<li>如果mostRight.right指向cur，让mostRight指向nil， cur向右移动</li>
</ul>
<p>Morris遍历， Python实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">morrisIn</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            mostRight = cur.left</span><br><span class="line">            <span class="keyword">while</span> mostRight.right <span class="keyword">and</span> mostRight.right != cur:</span><br><span class="line">                mostRight = mostRight.right</span><br><span class="line">            <span class="keyword">if</span> mostRight.right:</span><br><span class="line">                <span class="comment"># 中序</span></span><br><span class="line">                print(cur.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">                mostRight.right = <span class="literal">None</span></span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 先序</span></span><br><span class="line">                mostRight.right = cur</span><br><span class="line"><span class="comment">#                 print(cur.val, end=&quot; &quot;)</span></span><br><span class="line">                cur = cur.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(cur.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            cur = cur.right</span><br></pre></td></tr></table></figure>
<p>创建树节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>创建一颗平衡树</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> nums == []: <span class="keyword">return</span></span><br><span class="line">    mid = len(nums) &gt;&gt; <span class="number">1</span></span><br><span class="line">    root = Node(nums[mid])</span><br><span class="line">    root.left = buildTree(nums[:mid])</span><br><span class="line">    root.right = buildTree(nums[mid+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = buildTree(list(range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<p>显示树结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prettyPrintTree</span>(<span class="params">node, prefix=<span class="string">&quot;&quot;</span>, isLeft=True</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        print(<span class="string">&quot;Empty Tree&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        prettyPrintTree(node.right, prefix + (<span class="string">&quot;│   &quot;</span> <span class="keyword">if</span> isLeft <span class="keyword">else</span> <span class="string">&quot;    &quot;</span>), <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    print(prefix + (<span class="string">&quot;└── &quot;</span> <span class="keyword">if</span> isLeft <span class="keyword">else</span> <span class="string">&quot;┌── &quot;</span>) + str(node.val))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        prettyPrintTree(node.left, prefix + (<span class="string">&quot;    &quot;</span> <span class="keyword">if</span> isLeft <span class="keyword">else</span> <span class="string">&quot;│   &quot;</span>), <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prettyPrintTree(root)</span><br></pre></td></tr></table></figure>
<pre><code>│       ┌── 9
│   ┌── 8
│   │   └── 7
│   │       └── 6
└── 5
    │   ┌── 4
    │   │   └── 3
    └── 2
        └── 1
            └── 0
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">morrisIn(root)</span><br></pre></td></tr></table></figure>
<pre><code>0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>先序和中序只是打印的地方不同：</p>
<ul>
<li>第一次来带该节点为先序</li>
<li>第二次来来到节点为后序</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - KMP</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20KMP/</url>
    <content><![CDATA[<p>Kmp 算法比较重要。 是一个字符匹配算法， 做到时间复杂度是$O(n + m)$, 它是是对暴力算法的一个优化， 暴力算法的时间复杂度是$O(n * m)$</p>
<p>暴力算法的思路：</p>
<ul>
<li>i, j 两个指针，i指向匹配串, j 指向模式串</li>
<li>i, j 两个指针，如果匹配相等，i, j 指针同时往下跳</li>
<li>如果匹配不等， i 从匹配串开始的地方下一个从新开始匹配。 j 跳会到开头。</li>
</ul>
<p>暴力算法C++ 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ss[N], ms[M], ss表示字符串， ms表示模式串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ss[i + j] != ms[j]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配成功， 输出所有匹配成功的起始下标</span></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>KMP思路：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200813172058.png" alt=""></p>
<p>绿色之前都是匹配成功的， 在黑色点和黄色点匹配失败。假如存在蓝色的矩阵(最长相等前缀和后缀)，表示该部分都相等。1 = 2 = 3 = 4。所以这时候进行<br>
回退，就不用回退到开始的地方。只用回退到相等的地方，然后从相等的地方继续匹配。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200813172112.png" alt=""></p>
<p>接下来从黑色的点和蓝色的点继续匹配，如果匹配成功，继续匹配，如果不成功。进行回退。如果一直不成功就会回退到0，重新匹配。这就是KMP匹配的过程。</p>
<hr>
<p>求蓝色的矩阵部分(最长匹配前缀和后缀)就是KMP的核心。用数组表示最长匹配前缀和后缀所以叫next数组。里面存放的是长度，这里有个边界处理<code>如果下角标从1开始，下次该比较的地方就是长度 + 1</code>。</p>
<p>前缀和后缀不能包括整个字符串：</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aba</span><br><span class="line"></span><br><span class="line">前缀： a, ab</span><br><span class="line">后缀： a ba</span><br><span class="line"></span><br><span class="line">abcd:</span><br><span class="line"></span><br><span class="line">前缀： a, ab, abc</span><br><span class="line">后缀： d, cd, bcd</span><br></pre></td></tr></table></figure>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200813172127.png" alt=""></p>
<p>KMP算法C++实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ss[N], ms[M], ne[M]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求next数组</span></span><br><span class="line"><span class="comment">// 存放的时候ss 和 ms 都是从1开始的</span></span><br><span class="line"><span class="comment">// j表示最长前缀和后缀的长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果当前值i和最长前缀和后缀的下一个值不等，j 进行回退。最终会回退到0</span></span><br><span class="line">    <span class="keyword">while</span>( j &amp;&amp; ms[i] != ms[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">// 如果相等</span></span><br><span class="line">    <span class="keyword">if</span> (ms[i] == ms[j + <span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">// next数组存入数据</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配过程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; ss[i] != ms[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (ss[i] == ms[j + <span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">        <span class="comment">// 输出匹配成功时候的起始下标</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i - j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题目：-KMP字符串">题目： KMP字符串</h3>
<p>来源: <a href="https://www.acwing.com/problem/content/description/833/">https://www.acwing.com/problem/content/description/833/</a></p>
<p>给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p>
<p>模板串P在模式串S中多次作为子串出现。</p>
<p>求出模板串P在模式串S中所有出现的位置的起始下标。</p>
<p>输入格式<br>
第一行输入整数N，表示字符串P的长度。</p>
<p>第二行输入字符串P。</p>
<p>第三行输入整数M，表示字符串S的长度。</p>
<p>第四行输入字符串S。</p>
<p>输出格式<br>
共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。</p>
<p>数据范围</p>
<p>1≤N≤10^5</p>
<p>1≤M≤10^6</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure>
<p>C++ 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> ss[N], ms[N];</span><br><span class="line"><span class="keyword">int</span> n, m, ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; ms + <span class="number">1</span> &gt;&gt; n &gt;&gt; ss + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求next数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前值和最长前缀和后缀的下一个值进行比较</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; ms[i] != ms[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(ms[i] == ms[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KMP 匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// j = 0 表示模式串的长度为0</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; ss[i] != ms[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (ss[i] == ms[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 匹配成功后回退进行下次匹配</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 二分法</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p>二分法比较重要，然后又一定的模板。在此基础上可以进行一系列的修改，然后达到题目要求。需要注意有几个地方，二分法容易出错。</p>
<h3 id="整数二分">整数二分</h3>
<hr>
<p>二分法分<code>整数二分</code>和<code>浮点数二分</code>。</p>
<p>二分法使用的范围： 是以一个点，满足一个性质，可以把一个区间分成两个部分。这个性质可以是<code>单调性</code>也可以是其他的性质。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804093952.png" alt=""></p>
<p>两个模板可以求两个点：</p>
<p>第一个求黑色点的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// l, r 分别表示left左边界，和r有边界。</span></span><br><span class="line"><span class="comment">// cheak() 表示是否中当前的划分的性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid  = l + r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cheak(mid)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二个球蓝色的点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// l, r 分别表示left左边界，和r有边界。</span></span><br><span class="line"><span class="comment">// cheak() 表示是否中当前的划分的性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span>( l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cheak(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分的取整比较重要，有时候需要进行向上取证。不然就会一直进行循环。 当 <code>l = mid </code>的时候需要进行向上取证，而 <code>r = mid</code> 不需要进行向上取整数。</p>
<ul>
<li>l = mid的时候， 当l = r - 1, 如果是mid = l + r &gt;&gt; 1，如果cheak(mid) == true, 那么l = mid, 区间任然是<code>[l, r]</code></li>
<li>所以l = mid 的时候， mid = l + r + 1 &gt;&gt; 1; 进行向上取整数。</li>
<li>r不用此考虑，因为r本身就是向下取整，而且 while ( l &lt; r) 当r向下取整后就会终止循环。</li>
<li>所以在归并排序中mid = l + r &gt;&gt; 1, 左边分成<code>[l, mid]</code>右边是<code>[mid + 1, r]</code>区间。</li>
</ul>
<h3 id="浮点数二分">浮点数二分</h3>
<hr>
<p>浮点数二分不用考虑边界情况，左边界和右边界都是一样的。以一个点向左划分和向右划分都是一样的。所以不存在划分的边界条件。</p>
<p>以开三次方为例子。数据范围 -1000000  &lt;= n &lt;= 1000000</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( mid * mid * mid &gt;= n) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid * mid * mid &lt;= n) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<p>还有一种写法，就是循环100次数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> n;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid * mid * mid &gt;-= n) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
<p>PS:</p>
<p>这里r - l &gt; 1e-8 是提升精度的方式, 要求保留6位小数点的话，那么精度就要求1e8。循环100次也是提升精度的方式。 这里<code>mid * mid * mid &gt;= x</code>， 等于符号无所谓，可有可无，因为取不到等于的情况。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 位运算</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<hr>
<p>常见的两种操作，一个是找第几位的值是几，一个是找最后一个1是多少lowbit。</p>
<p>找第几位的值是几： 向右边移动k为然后进行与运算。 <code>x &gt;&gt; k &amp; 1</code></p>
<p>lowbit操作： <code>x &amp; -x</code>, -x等于反码+1</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804143547.png" alt=""></p>
<p>来源：</p>
<p><a href="https://www.acwing.com/problem/content/description/803/">https://www.acwing.com/problem/content/description/803/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a[i]) a[i] -= lowbit(a[i]), res++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, s = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= i &amp; -i) s ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 前缀和与差分</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p>前缀和唯一作用就是对一段区间方便求和。差分是前缀和的逆运算</p>
<h3 id="前缀和">前缀和</h3>
<p>一维数组前缀和：</p>
<p>规定： <code>s[i] = a[1] + a[2] + a[3] ...  + a[i]</code></p>
<p>所以， 方便求和 <code>a[i] ~ a[j]</code> :</p>
<p><code>s[j] = a[1] + a[2] + a[3]    ...  + a[i - 1] + a[i] + ... + a[j]</code></p>
<p><code>s[i - 1] = a[1] + a[2] + a[3] ... + a[i - 1]</code></p>
<p>所以 <code>s[j] - s[i - 1]</code> = $\sum_{i}^j a[i]$</p>
<p>c++ 模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 存放的时候一定注意是从1开始存放，这样前缀和 i - 1 就不会越界</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 求前缀和</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + q[i];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出 i ~ j 的累加和</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; s[j] - s[i - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二维数组前缀和：</p>
<p>这样一个二维数组，求蓝色部分的前缀和。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804094727.png" alt=""></p>
<p>求蓝色区域的面积。可以分别为两个部分的前缀和，一个是x轴方向的前缀和，一个是y方向的前缀和。</p>
<p><code>s[i][j]</code> 表示i * j 的整个数组的分别，比如 3 * 3 表示就是蓝色方框的数值。</p>
<p>所以<code>s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]</code></p>
<p>这里减去<code>s[i - 1][j - 1]</code> 是因为<code>s[i - 1][j] 和 s[i][j - 1]</code>都包含<code>s[i - 1][j - 1]</code>这个部分。</p>
<p>所以蓝色部分的用<code>s[i][j] </code>表示可以用<code>x1, y1, x2, y2</code>表示为：</p>
<p>蓝色部分的面积 = <code>s[x2][y2] = s[x1 - 1][y2]  + s[x2][y1 - 1] + s[x1 - 1][y1 - 1]</code></p>
<p>所以c++ 代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="number">0</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">cin</span> &gt;&gt; s[i][j];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span></span></span><br><span class="line"><span class="function"><span class="params">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">cout</span> &lt;&lt; s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="差分">差分</h3>
<p>差分运算是前缀和的逆运算。</p>
<p>有一个数组 <code>a[N]</code>， 构造一个辅助数组<code>b[N]</code>，</p>
<p>使得满足两个性质：</p>
<ol>
<li><code>a[i] = b[1] + b[2] + b[3] + ... + b[i]</code></li>
<li><code>b[i] = a[i] - a[i - 1]</code></li>
</ol>
<p>唯一一个应用就是在区间 <code>[l, r]</code> 区间内都加上 $c$。可以做到$O(1)$的复杂度。</p>
<ul>
<li>因为<code>a[i]</code>是<code>b[1 ~ i]</code>的前缀和。</li>
<li>在<code>b[l] + c</code>， 在 <code>b[r + 1] - c</code>,再求前缀和。</li>
</ul>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804094743.png" alt=""></p>
<p>在利用<code>b[i]</code>数组求<code>a[i]</code>的时候，在<code>b[l] + c</code>那么l之后的数据都会 + c，但是只要l ~ r区间 + c，所以在 r + 1的位置 - c就行了。</p>
<p>此外需要注意的是，在初始化b数组的时候，那么那么可以理解为<code>b[1 ~ i]</code> 都是0 然后在<code>l ~ l</code>的区间插入数据就可以了。</p>
<p>c++ 代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 读入a数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造b数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) insert(i, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行m次数的插入操作</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        insert(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终的数组, 利用前缀和进行构造</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二维矩阵的差分运算：</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804094805.png" alt=""></p>
<p>所以插入操作就是：</p>
<p><code>b[x1][y1] += c        </code><br>
<code>b[x1][y2 + 1] -= c    </code><br>
<code>b[x2 + 1][y1] -= c    </code><br>
<code>b[x2 + 1][y2 + 1] += c</code></p>
<p>接下来就是求前缀和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="comment">// 读取数组a</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造数组b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            insert(i, j, i, j, a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        insert(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 归并排序</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>题目来源： <a href="https://www.acwing.com/problem/content/789/">https://www.acwing.com/problem/content/789/</a></p>
<p>描述：</p>
<p>给定你一个长度为n的整数数列。</p>
<p>请你使用归并排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<hr>
<p>归并排序的思路：</p>
<ul>
<li>首先确定分界点，归并排序是以中间点划分，mid = left + right &gt;&gt; 1</li>
<li>然后递归去划分只有一个的情况</li>
<li>然后归并解决，利用双指针：</li>
</ul>
<blockquote>
<ul>
<li>i指针指向左半部分最左边，j指针指向右半部分最左边，i = left, r = mid + 1。</li>
<li>当i &lt;= mid 并且 j &lt;= right时， 如果q[i] &lt;= q[j] 那么q[i]复制到辅助数组，i++, 否者复制q[j]到辅助数组， j++.</li>
<li>必然有一个越界，把越界剩余的部分复制到辅助数组就行</li>
<li>然后把排序好的数组再复制回原数组</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    merge_sort(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 双指针算法</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>双指针算法是从暴力中优化，根据题目要求的某种性质进行优化。快排， 归排都用了双指针算法。把具有某种性质给提出来。简化时间复杂度的方法。</p>
<p>比如这样一道题目：</p>
<p>给定一些字符串，中间以空格隔开，输出每个字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    j = i;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++) <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s[k]);</span><br><span class="line">    i = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些C++的字符串读取操作：<br>
fgets(char数组, 最大读取长度, stdin)<br>
scanf()会读取到字符串为空，或者回车的情况。</p>
<p>所以双指针，统一可以写成这样模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(cheak(j, i)) j++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体题目逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最长连续不重复子序列， 来源：</p>
<p><a href="https://www.acwing.com/problem/content/801/">https://www.acwing.com/problem/content/801/</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> q[N], s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[q[i]]++;</span><br><span class="line">        <span class="keyword">while</span>(s[q[i]] &gt; <span class="number">1</span>) s[q[j++]]--;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组元素的目标和:</p>
<p><a href="https://www.acwing.com/problem/content/802/">https://www.acwing.com/problem/content/802/</a></p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804205942.png" alt=""></p>
<p>因为数组具有单调性，可以由一下组成：</p>
<ul>
<li>a[i] + b[j] &gt; x j–</li>
<li>否则i++</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[i] + b[j] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法 - 快速排序</title>
    <url>/2020/08/05/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20-%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>题目来源： <a href="https://www.acwing.com/problem/content/787/">https://www.acwing.com/problem/content/787/</a></p>
<p>描述：</p>
<p>给定你一个长度为n的整数数列。</p>
<p>请你使用快速排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<hr>
<p>快速排序是一种分而治之的一种排序方法，时间复杂度： 期望$O(nlogn)$</p>
<ul>
<li>首先确定一个划分值x: 可以是最左边，最右边，中间，随机值都是可行的</li>
<li>调整范围，也叫partition过程，把小于等于x的放在左边，大于等于x的放在右边</li>
<li>递归解决左右两端</li>
</ul>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200804205849.png" alt=""></p>
<p>第一种划分方法，利用双指针：</p>
<ul>
<li>i, j 分别表示最左边和最右边</li>
<li>如果q[i] &lt; x, i++</li>
<li>如果q[i] &gt;= x, 判断q[j] &gt; x:</li>
</ul>
<blockquote>
<ul>
<li>如果q[j] &gt; x, j–</li>
<li>如果q[j] &lt;= x, 交换 q[i], q[j]的值，然后i++, j–</li>
</ul>
</blockquote>
<p>第一种</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort(q, l, j);</span><br><span class="line">    quickSort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    quickSort(q, <span class="number">0</span>, n- <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种划分，小于x在左边，大于x在右边，等于x在中间：</p>
<ul>
<li>less = left - 1, more = right + 1, 指针p = left</li>
<li>如果q[p] &lt; x: 那么less向右边扩展，然后交换值, p指针下移动</li>
<li>如果q[p] == x: p指针下移</li>
<li>如果q[p] &gt; x: more 向左扩展，然后与指针p交换值。  #ps： 这里p指针不移动</li>
</ul>
<p>第二种</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = l, less = l - <span class="number">1</span>, more = r + <span class="number">1</span>, x = q[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (p &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[p] &lt; x) swap(q[++less], q[p++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[p] == x) p++;</span><br><span class="line">        <span class="keyword">else</span> swap(q[--more], q[p]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort(q, l, less);</span><br><span class="line">    quickSort(q, more, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    quickSort(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快排的边界条件：</p>
<ul>
<li>边界条件比较难处理，比如说第一个模板代码以q[l], q[r]作为边界的时候会进入死循环, 最好的方式就是记住模板。</li>
<li>以中间点为划分点和随机划分都不会出现这种情况。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - Trie 树</title>
    <url>/2020/08/14/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20Trie%20%E6%A0%91/</url>
    <content><![CDATA[<p>Trie 树又称为字典树，前缀树， 是一种用于高效存储和查找的字符串集合的数据结构。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200814105431.png" alt=""></p>
<p>结构如上图，头节点都为空，表示开始的节点。然后依次往下走，如果当前有以某一个字母为开头的继续往下走。如果没有创建出来，继续往下走。然后在以字母结尾的位置做出一个标记。记录有多少个字母是以它结尾的。</p>
<hr>
<h3 id="题目：-Trie字符串统计">题目： Trie字符串统计</h3>
<p>来源： <a href="https://www.acwing.com/problem/content/description/837/">https://www.acwing.com/problem/content/description/837/</a></p>
<p>维护一个字符串集合，支持两种操作：</p>
<p>“I x”向集合中插入一个字符串x；</p>
<p>“Q x”询问一个字符串在集合中出现了多少次。</p>
<p>共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</p>
<p>输入格式</p>
<p>第一行包含整数N，表示操作数。</p>
<p>接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。</p>
<p>输出格式</p>
<p>对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。</p>
<p>每个结果占一行。</p>
<p>数据范围</p>
<p>1≤N≤2∗10^4</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>C++实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 因为是只有小写字母，所以第二维度的值为26</span></span><br><span class="line"><span class="comment">// cnt 表示以某一个节点结尾的个数有多少个</span></span><br><span class="line"><span class="comment">// idx为下标的使用情况, 题目规定所有字符串的总长度是10^5</span></span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>) insert(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, query(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目-最大异或对">题目: 最大异或对</h3>
<p>来源： <a href="https://www.acwing.com/activity/content/problem/content/884/1/">https://www.acwing.com/activity/content/problem/content/884/1/</a></p>
<p>在给定的N个整数$A_1，A_2, ……, A_N$中选出两个进行xor（异或）运算，得到的结果最大是多少？</p>
<p>输入格式<br>
第一行输入一个整数N。</p>
<p>第二行输入N个整数$A_1～A_N$。</p>
<p>输出格式<br>
输出一个整数表示答案。</p>
<p>数据范围<br>
$1≤N≤10^5$,<br>
$0≤A_i&lt;2^{31}$<br>
输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="暴力解法：-时间复杂度-O-n-2">暴力解法： 时间复杂度$O(n^2)$</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, a[i] ^ a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="字典树解法：时间复杂度-O-n">字典树解法：时间复杂度$O(n)$</h4>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200820101455.png" alt=""></p>
<p>当某一位有异或值得时候就往有异或值为1的那条路径往下走，如果没有就直接往下走。</p>
<p>C++ 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// M 表示节点个数， N = 10^5, Ai = 31 位数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idx 表示节点的使用情况</span></span><br><span class="line"><span class="keyword">int</span> son[M][<span class="number">2</span>], idx;</span><br><span class="line"><span class="keyword">int</span> a[N], n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有节点就往下走，没有就创建出来继续往下走</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; ~i; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!s) s = ++idx;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="comment">// 当某一个节点有异或值得时候，那么加上该位的值，res += 1 &gt;&gt; i; 没有就是 res += 0 &gt;&gt; i, 这里等于0 所以省略掉</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; ~i; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (son[p][!s]) &#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = son[p][!s];</span><br><span class="line">        &#125; <span class="keyword">else</span> p = son[p][s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读入数据</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        insert(a[i]);    <span class="comment">// 创建字典树</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = <span class="built_in">max</span>(res, query(a[i]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 单调栈</title>
    <url>/2020/08/12/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p>栈结构实现，但是存入的数据具有某种性质的单调性。这个单调性可以是<code>递增</code>也可以是<code>递减</code>。</p>
<p>具体操作就是：</p>
<ul>
<li>确定某种单调性</li>
<li>按照这种单调性，从栈顶往栈底依次弹出数据</li>
<li>如果不满足这种单调性就一直弹出数据，直到满足性质或者弹空栈</li>
<li>压入数据</li>
</ul>
<hr>
<p>题目来源: <a href="https://www.acwing.com/problem/content/832/">https://www.acwing.com/problem/content/832/</a></p>
<p>给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。</p>
<p>输入格式</p>
<p>第一行包含整数N，表示数列长度。</p>
<p>第二行包含N个整数，表示整数数列。</p>
<p>输出格式</p>
<p>共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。</p>
<p>数据范围</p>
<p>1≤N≤10^5</p>
<p>1≤数列中元素≤10^9</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure>
<p>C++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, s[N], idx, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span>(idx &amp;&amp; s[idx] &gt;= x ) idx--;</span><br><span class="line">        <span class="keyword">if</span> (!idx) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[idx]);</span><br><span class="line">        s[++idx] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 单链表</title>
    <url>/2020/08/12/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>单链表结构，数据就像一个链条一样存储。每个数据都有指向下一个值得指针。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812173621.png" alt=""></p>
<p>链表的书写可以是利用指针，也可以是利用数组。利用指针书写，速度比较慢，这里利用数组进行链表的书写。</p>
<hr>
<p>题目来源： <a href="https://www.acwing.com/activity/content/problem/content/863/1/">https://www.acwing.com/activity/content/problem/content/863/1/</a></p>
<p>题目描述：</p>
<p>实现一个单链表，链表初始为空，支持三种操作：</p>
<p>(1) 向链表头插入一个数；</p>
<p>(2) 删除第k个插入的数后面的数；</p>
<p>(3) 在第k个插入的数后插入一个数</p>
<p>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p>注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p>
<p>输入格式<br>
第一行包含整数M，表示操作次数。</p>
<p>接下来M行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<p>(1) “H x”，表示向链表头插入一个数x。</p>
<p>(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。</p>
<p>(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。</p>
<p>输出格式<br>
共一行，将整个链表从头到尾输出。</p>
<p>数据范围<br>
1≤M≤100000<br>
所有操作保证合法。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></figure>
<p>C++代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头节点的下标，-1 表示空节点</span></span><br><span class="line"><span class="comment">// e[i] 表示当前的存放的值是多少</span></span><br><span class="line"><span class="comment">// ne[i] 表示当前值的next指针的角标存放</span></span><br><span class="line"><span class="comment">// idx 表示数组使用到哪里了</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头结点插入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第k个位置插入一个数。k = 0, 1, 2, 3, 4... n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; x;</span><br><span class="line">            add(a - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            <span class="keyword">if</span> (!a) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(a - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 单调队列</title>
    <url>/2020/08/13/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>和单调栈很相似，满足一定的单调性质，这些性质可以是单调递增，单调递减等等，使用的是队列结构。</p>
<p>具体操作就是：</p>
<ul>
<li>确定某种单调性</li>
<li>按照这种单调性，从对头往队尾进行弹出数据</li>
<li>如果不满足这种单调性就一直弹出数据，直到满足性质或者弹空</li>
<li>压入数据</li>
</ul>
<hr>
<h3 id="滑动窗口">滑动窗口</h3>
<p>题目来源： <a href="https://www.acwing.com/problem/content/156/">https://www.acwing.com/problem/content/156/</a></p>
<p>给定一个大小为n≤10^6的数组。</p>
<p>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>您只能在窗口中看到k个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为[1 3 -1 -3 5 3 6 7]，k为3。</p>
<table>
<thead>
<tr>
<th style="text-align:left">窗口位置</th>
<th style="text-align:left">最小值</th>
<th style="text-align:left">最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[1 3 -1] -3 5 3 6 7</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">1 [3 -1 -3] 5 3 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">1 3 [-1 -3 5] 3 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 [-3 5 3] 6 7</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 -3 [5 3 6] 7</td>
<td style="text-align:left">3</td>
<td style="text-align:left">6</td>
</tr>
<tr>
<td style="text-align:left">1 3 -1 -3 5 [3 6 7]</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
</tr>
</tbody>
</table>
<p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<p>输入格式</p>
<p>输入包含两行。</p>
<p>第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。</p>
<p>第二行有n个整数，代表数组的具体数值。</p>
<p>同行数据之间用空格隔开。</p>
<p>输出格式</p>
<p>输出包含两个。</p>
<p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p>
<p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>具有一定的单调性： 单增 和 单减</li>
<li>这里使用的是双端队列(对头，队尾都可以压入和弹出数据)</li>
<li>当添加数据的时候像栈一样</li>
<li>当下标过期的时候像队列一样，从队头弹出数据</li>
</ul>
<p>C++实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 1000010;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; a数组表示存放数据的数组</span><br><span class="line">&#x2F;&#x2F; q数组表示更新队列, 这里面存放的是下角标</span><br><span class="line">int a[N], q[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; k 表示窗口大小</span><br><span class="line">    int n, k;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">    &#x2F;&#x2F; 读入数据</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最小值</span><br><span class="line">    int hh &#x3D; 0, tt &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 下标过期，从队头弹出数据</span><br><span class="line">        if (hh &lt;&#x3D; tt &amp;&amp; i - q[hh] &gt;&#x3D; k) hh ++ ;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 具有一定单调性</span><br><span class="line">        &#x2F;&#x2F; 一直弹出数据直到队列为空或者满足单调性</span><br><span class="line">        &#x2F;&#x2F; 压入数据</span><br><span class="line">        while (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &gt;&#x3D; a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] &#x3D; i;</span><br><span class="line"></span><br><span class="line">        if (i &gt;&#x3D; k - 1) printf(&quot;%d &quot;, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最大值， 同理，只是单调性条件变化</span><br><span class="line">    hh &#x3D; 0, tt &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        if (hh &lt;&#x3D; tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 条件变为递增</span><br><span class="line">        while (hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] &#x3D; i;</span><br><span class="line"></span><br><span class="line">        if (i &gt;&#x3D; k - 1) printf(&quot;%d &quot;, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 双链表</title>
    <url>/2020/08/12/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>双链表是在单链表的基础上多了一个指针，可以直接找到某个节点的<code>前一个</code>值和<code>后一个</code>值。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812174835.png" alt=""></p>
<p>这里还是用数组来实现。为了方便边界处理操作，初始化最左边的是0， 最右边的是1。然后在01之间进行<code>增删改查</code>的操作。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812175445.png" alt=""></p>
<hr>
<p>题目来源： <a href="https://www.acwing.com/problem/content/829/">https://www.acwing.com/problem/content/829/</a></p>
<p>实现一个双链表，双链表初始为空，支持5种操作：</p>
<p>(1) 在最左侧插入一个数；</p>
<p>(2) 在最右侧插入一个数；</p>
<p>(3) 将第k个插入的数删除；</p>
<p>(4) 在第k个插入的数左侧插入一个数；</p>
<p>(5) 在第k个插入的数右侧插入一个数</p>
<p>现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。</p>
<p>注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p>
<p>输入格式<br>
第一行包含整数M，表示操作次数。</p>
<p>接下来M行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<p>(1) “L x”，表示在链表的最左端插入数x。</p>
<p>(2) “R x”，表示在链表的最右端插入数x。</p>
<p>(3) “D k”，表示将第k个插入的数删除。</p>
<p>(4) “IL k x”，表示在第k个插入的数左侧插入一个数。</p>
<p>(5) “IR k x”，表示在第k个插入的数右侧插入一个数。</p>
<p>输出格式:</p>
<p>共一行，将整个链表从左到右输出。</p>
<p>数据范围:</p>
<p>1≤M≤100000</p>
<p>所有操作保证合法。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">R 7</span><br><span class="line">D 1</span><br><span class="line">L 3</span><br><span class="line">IL 2 10</span><br><span class="line">D 3</span><br><span class="line">IL 2 7</span><br><span class="line">L 8</span><br><span class="line">R 9</span><br><span class="line">IL 4 7</span><br><span class="line">IR 2 2</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 7 7 3 2 9</span><br></pre></td></tr></table></figure>
<p>C++代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化双链表，初始化0，1两个节点，0的右边是1， 1的左边是0，idx从第二位开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>, idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在第k和位置后插入一个值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除第 k 个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> ( op == <span class="string">&quot;L&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            insert(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&quot;R&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            insert(l[<span class="number">1</span>], x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&quot;D&quot;</span> ) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&quot;IL&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 并查集</title>
    <url>/2020/08/23/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集是一种以集合的合并和查询的一种结构。</p>
<p>并查集：</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合当中</li>
</ol>
<p>基本原理：</p>
<p>每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点储存它的父节点，<code>p[x]</code>表示<code>x</code>的父节点。</p>
<p>问题1： 如何判断树根： if(p[x] == x)</p>
<p>问题2： 如何求x的集合编号： while(p[x] != x) x = p[x];</p>
<p>问题3： 如何合并两个集合： px 是x的集合编号， py 是y的集合编号。 p[p[x]] = py</p>
<h3 id="题目：-并查集">题目： 并查集</h3>
<p>一共有n个数，编号是1~n，最开始每个数各自在一个集合中。</p>
<p>现在要进行m个操作，操作共有两种：</p>
<p>“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；<br>
“Q a b”，询问编号为a和b的两个数是否在同一个集合中；<br>
输入格式<br>
第一行输入整数n和m。</p>
<p>接下来m行，每行包含一个操作指令，指令为“M a b”或“Q a b”中的一种。</p>
<p>输出格式<br>
对于每个询问指令”Q a b”，都要输出一个结果，如果a和b在同一集合内，则输出“Yes”，否则输出“No”。</p>
<p>每个结果占一行。</p>
<p>数据范围</p>
<p>$1≤n,m≤10^5$</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">M 1 2</span><br><span class="line">M 3 4</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">Q 3 4</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<p>c++ 代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集的核心： 查找 + 路径优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 初始化并查集的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目：-连通块中点的数量">题目： 连通块中点的数量</h3>
<p>给定一个包含n个点（编号为1~n）的无向图，初始时图中没有边。</p>
<p>现在要进行m个操作，操作共有三种：</p>
<ol>
<li>“C a b”，在点a和点b之间连一条边，a和b可能相等；</li>
<li>“Q1 a b”，询问点a和点b是否在同一个连通块中，a和b可能相等；</li>
<li>“Q2 a”，询问点a所在连通块中点的数量；<br>
输入格式</li>
</ol>
<p>第一行输入整数n和m。</p>
<p>接下来m行，每行包含一个操作指令，指令为“C a b”，“Q1 a b”或“Q2 a”中的一种。</p>
<p>输出格式</p>
<p>对于每个询问指令”Q1 a b”，如果a和b在同一个连通块中，则输出“Yes”，否则输出“No”。</p>
<p>对于每个询问指令“Q2 a”，输出一个整数表示点a所在连通块中点的数量</p>
<p>每个结果占一行。</p>
<p>数据范围</p>
<p>$1≤n,m≤10^5$</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="思路：">思路：</h4>
<p>只需要在上一题的基础上添加一个size数组，用来维护根节点所在集合的元素个数就好。只需要维护根节点元素的个数就行。</p>
<p>C++实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], cnt[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集的核心： 查找 + 路径优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 初始化并查集的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line">            cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 1e5 + 10;</span><br><span class="line">int p[N], s[N], n, m;</span><br><span class="line"></span><br><span class="line">int find(int x) &#123;</span><br><span class="line">    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        p[i] &#x3D; i;</span><br><span class="line">        s[i] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(m--) &#123;</span><br><span class="line">        char op[5];</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%s&quot;, op);</span><br><span class="line">        if (op[0] &#x3D;&#x3D; &#39;C&#39;) &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            if (find(a) &#x3D;&#x3D; find(b)) continue;</span><br><span class="line">            p[find(a)] &#x3D; find(b);</span><br><span class="line">            s[b] +&#x3D; s[a];</span><br><span class="line">        &#125; else if (op[1] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot; &amp;a, &amp;b);</span><br><span class="line">            if (find(a) &#x3D;&#x3D; find(b)) puts(&quot;Yes&quot;);</span><br><span class="line">            else puts(&quot;No&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            printf(&quot;%d\n&quot;, s[a]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="题目：-食物链">题目： 食物链</h3>
<p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。</p>
<p>A吃B， B吃C，C吃A。</p>
<p>现有N个动物，以1－N编号。</p>
<p>每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。</p>
<p>有人用两种说法对这N个动物所构成的食物链关系进行描述：</p>
<p>第一种说法是”1 X Y”，表示X和Y是同类。</p>
<p>第二种说法是”2 X Y”，表示X吃Y。</p>
<p>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。</p>
<p>当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p>
<p>1） 当前的话与前面的某些真的话冲突，就是假话；<br>
2） 当前的话中X或Y比N大，就是假话；<br>
3） 当前的话表示X吃X，就是假话。</p>
<p>你的任务是根据给定的N和K句话，输出假话的总数。</p>
<p>输入格式<br>
第一行是两个整数N和K，以一个空格分隔。</p>
<p>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。</p>
<p>若D=1，则表示X和Y是同类。</p>
<p>若D=2，则表示X吃Y。</p>
<p>输出格式<br>
只有一个整数，表示假话的数目。</p>
<p>数据范围</p>
<p>1≤N≤50000,<br>
0≤K≤100000</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1</span><br><span class="line">2 1 2</span><br><span class="line">2 2 3</span><br><span class="line">2 3 3</span><br><span class="line">1 1 3</span><br><span class="line">2 3 1</span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="思路：-2">思路：</h4>
<p>这里使用并查集来做，利用集合的合并来表示两个物种间是否在之前出现过。这里开一个格外数组，用来维护某点到根节点的距离。这个距离取模为3就表示第几代。形成一个环状结构，如果取模相等就表示两个物种是同一个物种，如果取模不等切相差为1就表示该物种间是一种吃与被吃的关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N], d[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p[x] != x ) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// 初始化并查集， 每个节点的父都为自己</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( m-- ) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有物种不存在</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) res++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 找到x, y 节点的父</span></span><br><span class="line">            <span class="keyword">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// px == py 表示以前合并过(合并到一个集合)， d[x]表示节点 x 到根节点的距离， d[y] 表示节点 y 到根节点的距离</span></span><br><span class="line">                <span class="comment">// d[x] % 3 != d[y] % 3 表示为不是同一类。所以(d[x] - d[y]) % 3 != 0表示非同一类</span></span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) res++;</span><br><span class="line">                <span class="comment">// px != py 表示x, y 没有合并过</span></span><br><span class="line">                <span class="comment">// p[x]的距离由于可以反推，d[x]和d[y]是同类。所以 (d[x] + d[p[x]]) % 3 = d[y] % 3</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py ) &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// px == py 表示以前合并过</span></span><br><span class="line">                <span class="comment">// 同理(d[x] - d[1] - 1) % 3 != 0 说明他们相差不止一代</span></span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) res++;</span><br><span class="line">                <span class="comment">// 没有合并过，他们是吃与被吃的关系，所以他们相差一代</span></span><br><span class="line">                <span class="comment">// 就是d[y] - d[x] + 1。同理也是p[x]的距离由于可以反推得到。</span></span><br><span class="line">                <span class="comment">// (d[x] + d[p[x]] - 1) % 3 = d[y] % 3</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py) &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 栈</title>
    <url>/2020/08/12/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E6%A0%88/</url>
    <content><![CDATA[<p>栈是一只先进后出的一种数据结构。</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812180837.png" alt=""></p>
<p>压入和弹出都是在栈顶操作，所以先进入的在底部，后进入的再栈顶部。利用数组很容易实现。<br>
具体边界看个人习惯的实现， 这里实现的是：</p>
<ul>
<li>idx = 0 表示栈为空。</li>
<li>所以添加数据就是<code>q[++idx] = x</code></li>
</ul>
<hr>
<p>题目来源： <a href="https://www.acwing.com/problem/content/830/">https://www.acwing.com/problem/content/830/</a></p>
<p>实现一个栈，栈初始为空，支持四种操作：</p>
<p>(1) “push x” – 向栈顶插入一个数x；</p>
<p>(2) “pop” – 从栈顶弹出一个数；</p>
<p>(3) “empty” – 判断栈是否为空；</p>
<p>(4) “query” – 查询栈顶元素。</p>
<p>现在要对栈进行M个操作，其中的每个操作3和操作4都要输出相应的结果。</p>
<p>输入格式<br>
第一行包含整数M，表示操作次数。</p>
<p>接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。</p>
<p>输出格式<br>
对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。</p>
<p>其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示栈顶元素的值。</p>
<p>数据范围<br>
1≤M≤100000,<br>
1≤x≤10^9<br>
所有操作保证合法。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 5</span><br><span class="line">query</span><br><span class="line">push 6</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 4</span><br><span class="line">query</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">YES</span><br><span class="line">4</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<p>C++代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> s[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            s[ ++ idx] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&quot;pop&quot;</span> ) idx--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) <span class="built_in">cout</span> &lt;&lt; (idx? <span class="string">&quot;NO&quot;</span>: <span class="string">&quot;YES&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; s[idx] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 队列</title>
    <url>/2020/08/12/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%20%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>队列是一种先进先出的一种数据结构。就像排队一样</p>
<p><img src="https://blogmypic.oss-cn-beijing.aliyuncs.com/img/20200812183139.png" alt=""></p>
<p>利用数组实现。队列这里的边界实现，tt 表示队尾， 初始值为 -1，hh 表示队头， 初始值为 0。</p>
<ul>
<li>tt &gt; hh 表示 队列为空</li>
<li>从队尾添加数据就是<code>q[++tt] = x</code></li>
</ul>
<hr>
<p>题目来源： <a href="https://www.acwing.com/problem/content/831/">https://www.acwing.com/problem/content/831/</a></p>
<p>实现一个队列，队列初始为空，支持四种操作：</p>
<p>(1) “push x” – 向队尾插入一个数x；</p>
<p>(2) “pop” – 从队头弹出一个数；</p>
<p>(3) “empty” – 判断队列是否为空；</p>
<p>(4) “query” – 查询队头元素。</p>
<p>现在要对队列进行M个操作，其中的每个操作3和操作4都要输出相应的结果。</p>
<p>输入格式<br>
第一行包含整数M，表示操作次数。</p>
<p>接下来M行，每行包含一个操作命令，操作命令为”push x”，”pop”，”empty”，”query”中的一种。</p>
<p>输出格式</p>
<p>对于每个”empty”和”query”操作都要输出一个查询结果，每个结果占一行。</p>
<p>其中，”empty”操作的查询结果为“YES”或“NO”，”query”操作的查询结果为一个整数，表示队头元素的值。</p>
<p>数据范围</p>
<p>1≤M≤100000,</p>
<p>1≤x≤10^9,</p>
<p>所有操作保证合法。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 6</span><br><span class="line">empty</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 3</span><br><span class="line">push 4</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">push 6</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">6</span><br><span class="line">YES</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>C++代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> ( op == <span class="string">&quot;push&quot;</span> ) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            q[++tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&quot;empty&quot;</span> ) <span class="built_in">cout</span> &lt;&lt; (hh &lt;= tt ? <span class="string">&quot;NO&quot;</span>: <span class="string">&quot;YES&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="string">&quot;query&quot;</span>) <span class="built_in">cout</span> &lt;&lt; q[hh] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> hh++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 - 04 基础两层神经网络</title>
    <url>/2020/08/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20-%2004_%E5%9F%BA%E7%A1%80torch%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>PyTorch是一个基于Python的科学计算库，它有以下特点:</p>
<ul>
<li>类似于NumPy，但是它可以使用GPU</li>
<li>可以用它定义深度学习模型，可以灵活地进行深度学习模型的训练和使用</li>
</ul>
<h2 id="Tensor">Tensor</h2>
<p>Tensor类似于numpy的ndarray，唯一的区别是tensor可以在gpu上加速计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p>构造一个初始化5 * 3 的矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1.2584e-23, 4.5800e-41, 5.5303e-22],
        [4.5800e-41, 0.0000e+00, 0.0000e+00],
        [0.0000e+00, 0.0000e+00, 0.0000e+00],
        [0.0000e+00, 4.2603e-21, 1.4013e-45],
        [5.5193e-22, 4.5800e-41, 0.0000e+00]])
</code></pre>
<p>构建一个随机初始化的矩阵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rand 生成的都是正数，randn生成的数有正有负</span></span><br><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">x = torch.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0.9556, 0.5058, 0.0706],
        [0.2486, 0.8324, 0.8027],
        [0.4677, 0.9293, 0.5427],
        [0.7236, 0.9158, 0.4789],
        [0.2861, 0.2748, 0.8777]])
tensor([[ 1.8956,  0.2862,  0.0363],
        [ 0.8295, -0.8973, -0.7135],
        [-0.7953,  0.7180, -0.0232],
        [-0.3304, -0.0801, -0.1258],
        [ 0.3730, -0.0505,  0.9129]])
</code></pre>
<p>构建一个全部为0，类型为long的矩阵:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]])
</code></pre>
<p>从数据直接直接构建tensor:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([5.5000, 3.0000])
</code></pre>
<p>也可以从一个已有的tensor构建一个tensor。这些方法会重用原来tensor的特征，例如，数据类型，除非提供新的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建新的矩阵的同时可以改变形状， 数据类型</span></span><br><span class="line">x = x.new_ones(<span class="number">3</span>, <span class="number">5</span>, dtype=torch.double) <span class="comment"># new methodstake in size</span></span><br><span class="line">print(x)</span><br><span class="line">x = x.new_zeros(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># randn_like 只是沿用了之前的形状</span></span><br><span class="line">x = torch.randn_like(x, dtype=torch.float)  <span class="comment"># override dtype</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.]], dtype=torch.float64)
tensor([[0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]], dtype=torch.float64)
tensor([[-0.3154, -0.2669, -0.0327, -0.0288,  0.6338],
        [ 1.8162,  1.5946, -1.3593, -0.8494,  1.5819],
        [-0.2012, -1.8754, -0.4515, -0.6153,  0.0842]])
</code></pre>
<p>得到tensor的形状:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#返回的是一个tuple, torch.Size是一个tuple</span></span><br><span class="line">y = x.size()</span><br><span class="line">print(y, type(y))</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([3, 5]) &lt;class 'torch.Size'&gt;
</code></pre>
<div class='alert alert-info'>
    <h4>Attention</h4>
    <p>torch.Size is tuple</p>
</div>
<p>Operations</p>
<p>有很多种tensor运算。我们先介绍加法运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.rand(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.1155,  0.1429,  0.2812,  0.0049,  1.1452],
        [ 1.8705,  2.3386, -1.1029,  0.1432,  2.5273],
        [ 0.2852, -1.7390,  0.1234, -0.5170,  0.1819]])
</code></pre>
<p>另一种着加法的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(torch.add(x, y))</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.1155,  0.1429,  0.2812,  0.0049,  1.1452],
        [ 1.8705,  2.3386, -1.1029,  0.1432,  2.5273],
        [ 0.2852, -1.7390,  0.1234, -0.5170,  0.1819]])
</code></pre>
<p>加法：把输出作为一个变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = x + y</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">result = torch.empty(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">torch.add(x, y, out=result)  <span class="comment"># overwirte before tensor</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.1155,  0.1429,  0.2812,  0.0049,  1.1452],
        [ 1.8705,  2.3386, -1.1029,  0.1432,  2.5273],
        [ 0.2852, -1.7390,  0.1234, -0.5170,  0.1819]])
tensor([[-0.1155,  0.1429,  0.2812,  0.0049,  1.1452],
        [ 1.8705,  2.3386, -1.1029,  0.1432,  2.5273],
        [ 0.2852, -1.7390,  0.1234, -0.5170,  0.1819]])
</code></pre>
<p>in-place加法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add x to y</span></span><br><span class="line">y.add(x)</span><br><span class="line">print(y)</span><br><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0.1999, 0.4098, 0.3139, 0.0337, 0.5115],
        [0.0543, 0.7440, 0.2564, 0.9927, 0.9454],
        [0.4864, 0.1365, 0.5750, 0.0983, 0.0976]])
tensor([[-0.1155,  0.1429,  0.2812,  0.0049,  1.1452],
        [ 1.8705,  2.3386, -1.1029,  0.1432,  2.5273],
        [ 0.2852, -1.7390,  0.1234, -0.5170,  0.1819]])
</code></pre>
<div class="alert alert-info"><h4>注意</h4><p>任何in-place的运算都会以``_``结尾。
    举例来说：``x.copy_(y)``, ``x.t_()``, 会改变 ``x``。</p></div>
<p>各种类似NumPy的indexing都可以在PyTorch tensor上面使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x)</span><br><span class="line">print(x[:, <span class="number">1</span>])  <span class="comment"># 表示所有列表的index 1</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.3154, -0.2669, -0.0327, -0.0288,  0.6338],
        [ 1.8162,  1.5946, -1.3593, -0.8494,  1.5819],
        [-0.2012, -1.8754, -0.4515, -0.6153,  0.0842]])
tensor([-0.2669,  1.5946, -1.8754])
</code></pre>
<p>Resizing: 如果你希望resize/reshape一个tensor，可以使用torch.view：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用reshape返回的是一个新的tensor</span></span><br><span class="line">print(x.reshape(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># resizing: -1表示自动帮你计算你需要的纬度，但是必须除尽</span></span><br><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">z = x.view(<span class="number">-1</span>, <span class="number">8</span>) <span class="comment"># the size -1 is inferred from other dimensions</span></span><br><span class="line">print(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.3154, -0.2669, -0.0327],
        [-0.0288,  0.6338,  1.8162],
        [ 1.5946, -1.3593, -0.8494],
        [ 1.5819, -0.2012, -1.8754],
        [-0.4515, -0.6153,  0.0842]])
tensor([[-0.3154, -0.2669, -0.0327, -0.0288,  0.6338],
        [ 1.8162,  1.5946, -1.3593, -0.8494,  1.5819],
        [-0.2012, -1.8754, -0.4515, -0.6153,  0.0842]])
torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1</span>])</span><br><span class="line">print(x.item())</span><br><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure>
<pre><code>1
-0.4120529592037201
</code></pre>
<p><strong>更多阅读</strong></p>
<p>各种Tensor operations, 包括transposing, indexing, slicing,<br>
mathematical operations, linear algebra, random numbers在<br>
<code>&lt;https://pytorch.org/docs/torch&gt;</code>.</p>
<h2 id="Numpy和Tensor之间的转化">Numpy和Tensor之间的转化</h2>
<p>在Torch Tensor和NumPy array之间相互转化非常容易。</p>
<p>Torch Tensor和NumPy array会共享内存，所以改变其中一项也会改变另一项。</p>
<p>把Torch Tensor转变成NumPy Array</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1., 1., 1., 1., 1.])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a.numpy()</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>[1. 1. 1. 1. 1.]
</code></pre>
<p>改变numpy array里面的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 猜测：原数据地址都是一样的只是形式不同而已</span></span><br><span class="line">a.add_(<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([2., 2., 2., 2., 2.])
[2. 2. 2. 2. 2.]
</code></pre>
<p>把NumPy ndarray转成Torch Tensor</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>[2. 2. 2. 2. 2.]
tensor([2., 2., 2., 2., 2.], dtype=torch.float64)
</code></pre>
<p>所有CPU上的Tensor都支持转成numpy或者从numpy转成Tensor。</p>
<h2 id="CUDA-Tensors">CUDA Tensors</h2>
<p>使用<code>.to</code>方法，Tensor可以被移动到别的device上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># let us run this cell only if CUDA is available</span></span><br><span class="line"><span class="comment"># We will use ``torch.device`` objects to move tensors in and out of GPU</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span>)          <span class="comment"># a CUDA device object</span></span><br><span class="line">    y = torch.ones_like(x, device=device)  <span class="comment"># directly create a tensor on GPU</span></span><br><span class="line">    x = x.to(device)                       <span class="comment"># or just use strings ``.to(&quot;cuda&quot;)``</span></span><br><span class="line">    z = x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(<span class="string">&quot;cpu&quot;</span>, torch.double))       <span class="comment"># ``.to`` can also change dtype together!</span></span><br></pre></td></tr></table></figure>
<h2 id="热身-用numpy实现两层神经网络">热身: 用numpy实现两层神经网络</h2>
<p>一个全连接ReLU神经网络，一个隐藏层，没有bias。用来从x预测y，使用L2 Loss。</p>
<p>这一实现完全使用numpy来计算前向神经网络，loss，和反向传播。</p>
<p>numpy ndarray是一个普通的n维array。它不知道任何关于深度学习或者梯度(gradient)的知识，也不知道计算图(computation graph)，只是一种用来计算数学运算的数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># N is batch size; D_in is input dimension;</span></span><br><span class="line"><span class="comment"># H is hidden dimension; D_out is output dimension.</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create radnom input and output data</span></span><br><span class="line">x = np.random.randn(N, D_in)</span><br><span class="line">y = np.random.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Randomly initialize wights</span></span><br><span class="line">w1 = np.random.randn(D_in, H)</span><br><span class="line">w2 = np.random.randn(H, D_out)</span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">500</span>): <span class="comment"># traing 500 times</span></span><br><span class="line">    <span class="comment"># Forward pass: compute predict y</span></span><br><span class="line">    h = x.dot(w1)</span><br><span class="line">    h_relu = np.maximum(h, <span class="number">0</span>)</span><br><span class="line">    y_pred = h_relu.dot(w2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute and print loss</span></span><br><span class="line">    loss = np.square(y_pred - y).sum()</span><br><span class="line">    print(t, loss)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># backpro compute gradients of w1 and w2 with respect to loss</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># loss = (y_pred -y) ** 2</span></span><br><span class="line">    grad_y_pred = <span class="number">2.0</span> * (y_pred - y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># backward gradients ones by ones</span></span><br><span class="line">    grad_w2 = h_relu.T.dot(grad_y_pred)</span><br><span class="line">    grad_h_relu = grad_y_pred.dot(w2.T)</span><br><span class="line">    grad_h = grad_h_relu.copy()</span><br><span class="line">    grad_h[h &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    grad_w1= x.T.dot(grad_h)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update weights</span></span><br><span class="line">    w1 -= learning_rate * grad_w1</span><br><span class="line">    w2 -= learning_rate * grad_w2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>0 23734775.983870674
1 18164484.466070224
2 14837301.198169785
3 12230863.71148485
…………
498 0.00021707495985364252
499 0.00020994768522520618
</code></pre>
<h2 id="PyTorch-Tensors">PyTorch: Tensors</h2>
<p>这次我们使用PyTorch tensors来创建前向神经网络，计算损失，以及反向传播。</p>
<p>一个PyTorch Tensor很像一个numpy的ndarray。但是它和numpy ndarray最大的区别是，PyTorch Tensor可以在CPU或者GPU上运算。如果想要在GPU上运算，就需要把Tensor换成cuda类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">dtype = torch.float</span><br><span class="line">device = torch.device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"><span class="comment"># device = torch.device(&#x27;cuda:0&#x27;) # this run on GPU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># N is batch size; D_in is input dimension;</span></span><br><span class="line"><span class="comment"># H is hidden dimension; D_out is output dimension.</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create random input and output data</span></span><br><span class="line">x = torch.randn(N, D_in, device=device, dtype=dtype)</span><br><span class="line">y = torch.randn(N, D_out, device=device, dtype=dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Randomly initialize weights</span></span><br><span class="line">w1 = torch.randn(D_in, H, device=device, dtype=dtype)</span><br><span class="line">w2 = torch.randn(H, D_out, device=device, dtype=dtype)</span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    <span class="comment"># Forward pass: compute predicted y</span></span><br><span class="line">    h = x.mm(w1)</span><br><span class="line">    h_relu = h.clamp(min=<span class="number">0</span>)</span><br><span class="line">    y_pred = h_relu.mm(w2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute and print loss</span></span><br><span class="line">    loss = (y_pred - y).pow(<span class="number">2</span>).sum().item()</span><br><span class="line">    print(t, loss)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Backprop to compute gradients of w1 and w2</span></span><br><span class="line">    grad_y_pred = <span class="number">2.0</span> * (y_pred - y)</span><br><span class="line">    grad_w2 = h_relu.t().mm(grad_y_pred)</span><br><span class="line">    grad_h_relu = grad_y_pred.mm(w2.t())</span><br><span class="line">    grad_h = grad_h_relu.clone()</span><br><span class="line">    grad_h[h &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    grad_w1 = x.t().mm(grad_h)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># update weights using gradient descent</span></span><br><span class="line">    w1 -= learning_rate * grad_w1</span><br><span class="line">    w2 -= learning_rate * grad_w2</span><br></pre></td></tr></table></figure>
<pre><code>0 23538196.0
1 18919592.0
…………
498 0.00025007393560372293
499 0.0002459314709994942
</code></pre>
<p>简单的autograd</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create tensors. requires_grad=True. Default False</span></span><br><span class="line"><span class="comment"># tensor 和 Tensor的区别， tensor是整形， Tensor浮点形</span></span><br><span class="line">x = torch.tensor(<span class="number">1.</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">w = torch.tensor(<span class="number">2.</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor(<span class="number">3.</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a computation graph.</span></span><br><span class="line">y = w * x + b   <span class="comment"># y = 2 * x + 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute gradients.</span></span><br><span class="line">y.backward()</span><br><span class="line"></span><br><span class="line">print(x.grad)  <span class="comment"># x.grad = 2</span></span><br><span class="line">print(w.grad)  <span class="comment"># w.grad = 1</span></span><br><span class="line">print(b.grad)  <span class="comment"># b.grad = 1</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor(2.)
tensor(1.)
tensor(1.)
</code></pre>
<h2 id="PyTorch-Tensor和autograd">PyTorch: Tensor和autograd</h2>
<p>PyTorch的一个重要功能就是autograd，也就是说只要定义了forward pass(前向神经网络)，计算了loss之后，PyTorch可以自动求导计算模型所有参数的梯度。</p>
<p>一个PyTorch的Tensor表示计算图中的一个节点。如果<code>x</code>是一个Tensor并且<code>x.requires_grad=True</code>那么<code>x.grad</code>是另一个储存着<code>x</code>当前梯度(相对于一个scalar，常常是loss)的向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">dtype = torch.float</span><br><span class="line">device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="comment"># device = torch.device(&quot;cuda:0&quot;) # Uncomment this to run on GPU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># N 是 batch size; D_in 是 input dimension;</span></span><br><span class="line"><span class="comment"># H 是 hidden dimension; D_out 是 output dimension.</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建随机的Tensor来保存输入和输出</span></span><br><span class="line"><span class="comment"># 设定requires_grad=False表示在反向传播的时候我们不需要计算gradient</span></span><br><span class="line">x = torch.randn(N, D_in, device=device, dtype=dtype)</span><br><span class="line">y = torch.randn(N, D_out, device=device, dtype=dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建随机的Tensor和权重。</span></span><br><span class="line"><span class="comment"># 设置requires_grad=True表示我们希望反向传播的时候计算Tensor的gradient</span></span><br><span class="line">w1 = torch.randn(D_in, H, device=device, dtype=dtype, requires_grad=<span class="literal">True</span>)</span><br><span class="line">w2 = torch.randn(H, D_out, device=device, dtype=dtype, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    <span class="comment"># 前向传播:通过Tensor预测y；这个和普通的神经网络的前向传播没有任何不同，</span></span><br><span class="line">    <span class="comment"># 但是我们不需要保存网络的中间运算结果，因为我们不需要手动计算反向传播。</span></span><br><span class="line">    y_pred = x.mm(w1).clamp(min=<span class="number">0</span>).mm(w2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过前向传播计算loss</span></span><br><span class="line">    <span class="comment"># loss是一个形状为(1，)的Tensor</span></span><br><span class="line">    <span class="comment"># loss.item()可以给我们返回一个loss的scalar</span></span><br><span class="line">    loss = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我们可以手动做gradient descent(后面我们会介绍自动的方法)。</span></span><br><span class="line">    <span class="comment"># 用torch.no_grad()包含以下statements，因为w1和w2都是requires_grad=True，</span></span><br><span class="line">    <span class="comment"># 但是在更新weights之后我们并不需要再做autograd。</span></span><br><span class="line">    <span class="comment"># 另一种方法是在weight.data和weight.grad.data上做操作，这样就不会对grad产生影响。</span></span><br><span class="line">    <span class="comment"># tensor.data会我们一个tensor，这个tensor和原来的tensor指向相同的内存空间，</span></span><br><span class="line">    <span class="comment"># 但是不会记录计算图的历史。</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        w1 -= learning_rate * w1.grad</span><br><span class="line">        w2 -= learning_rate * w2.grad</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Manually zero the gradients after updating weights</span></span><br><span class="line">        w1.grad.zero_()</span><br><span class="line">        w2.grad.zero_()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意这里的w1和w2都是grad.zero_()而不是grad_zero_()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>0 24256240.0
1 20202350.0
…………
498 0.0007593631744384766
499 0.0007417545421048999
</code></pre>
<h2 id="PyTorch-nn">PyTorch:nn</h2>
<p>这次我们使用PyTorch中nn这个库来构建网络。<br>
用PyTorch autograd来构建计算图和计算gradients，<br>
然后PyTorch会帮我们自动计算gradient。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># N is batch size; D_in is input dimension;</span></span><br><span class="line"><span class="comment"># H is hidden dimension; D_out is output dimension.</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create random Tensors to hold inputs and outputs</span></span><br><span class="line">x = torch.randn(N, D_in)</span><br><span class="line">y = torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the nn package to define our model as a sequence of layers. nn.Sequential</span></span><br><span class="line"><span class="comment"># is a Module which contains other Modules, and applies them in sequence to</span></span><br><span class="line"><span class="comment"># produce its output. Each Linear Module computes output from input using a</span></span><br><span class="line"><span class="comment"># linear function, and holds internal Tensors for its weight and bias.</span></span><br><span class="line">model = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(D_in, H),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(H, D_out)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loss_fn = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">learning_rate = <span class="number">1e-4</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    y_pred = model(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute and print loss. We pass Tensors containing the predicted and true</span></span><br><span class="line">    <span class="comment"># values of y, and the loss function returns a Tensor containing the</span></span><br><span class="line">    <span class="comment"># loss.</span></span><br><span class="line">    loss = loss_fn(y_pred, y)</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Zero the gradients before running the backward pass.</span></span><br><span class="line">    model.zero_grad()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Backward pass: compute gradient of the loss with respect to all the learnable</span></span><br><span class="line">    <span class="comment"># parameters of the model. Internally, the parameters of each Module are stored</span></span><br><span class="line">    <span class="comment"># in Tensors with requires_grad=True, so this call will compute gradients for</span></span><br><span class="line">    <span class="comment"># all learnable parameters in the model.</span></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">            param -= learning_rate * param.grad</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>0 699.1046752929688
1 647.9535522460938
…………
498 9.313514510722598e-07
499 9.014782449412451e-07
</code></pre>
<h2 id="PyTorch-optim">PyTorch: optim</h2>
<p>这一次我们不再手动更新模型的weights,而是使用optim这个包来帮助我们更新参数。<br>
optim这个package提供了各种不同的模型优化方法，包括SGD+momentum, RMSProp, Adam等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># N is batch size; D_in is input dimension;</span></span><br><span class="line"><span class="comment"># H is hidden dimension; D_out is output dimension.</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create random tensor input and output data</span></span><br><span class="line">x = torch.randn(N, D_in)</span><br><span class="line">Y = torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the nn package to define our model and loss function</span></span><br><span class="line">model = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(D_in, H),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(H, D_out)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">loss_fn = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">learning_rate = <span class="number">1e-4</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    <span class="comment"># Forward pass: compute predicted y by passing x to the model.</span></span><br><span class="line">    y_pred = model(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    loss = loss_fn(y_pred, y)</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Before the backward pass, use the optimizer object to zero all of the</span></span><br><span class="line">    <span class="comment"># gradients for the variables it will update (which are the learnable</span></span><br><span class="line">    <span class="comment"># weights of the model). This is because by default, gradients are</span></span><br><span class="line">    <span class="comment"># accumulated in buffers( i.e, not overwritten) whenever .backward()</span></span><br><span class="line">    <span class="comment"># is called. Checkout docs of torch.autograd.backward for more details.</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Backward pass: compute gradient of the loss with respect to model</span></span><br><span class="line">    <span class="comment"># parameters</span></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calling the step function on an Optimizer makes an update to its</span></span><br><span class="line">    <span class="comment"># parameters</span></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>
<pre><code>0 711.3644409179688
1 694.257080078125
…………
498 2.771603502260689e-10
499 2.650134556247963e-10
</code></pre>
<h2 id="PyTorch-自定义-nn-Modules">PyTorch: 自定义 nn Modules</h2>
<p>我们可以定义一个模型，这个模型继承自nn.Module类。如果需要定义一个比Sequential模型更加复杂的模型，就需要定义nn.Module模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLayerNet</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, D_in, H, D_out</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        In the constructor we instantiate two nn.Linear modules and assign them as</span></span><br><span class="line"><span class="string">        member variables.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        super(TwoLayerNet, self).__init__()</span><br><span class="line">        self.linear1 = torch.nn.Linear(D_in, H)</span><br><span class="line">        self.linear2 = torch.nn.Linear(H, D_out)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        In the forward function we accept a Tensor of input data and we must return</span></span><br><span class="line"><span class="string">        a Tensor of output data. We can use Modules defined in the constructor as</span></span><br><span class="line"><span class="string">        well as arbitrary operators on Tensors.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        h_relu = self.linear1(x).clamp(min=<span class="number">0</span>)</span><br><span class="line">        y_pred = self.linear2(h_relu)</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># N is batch size; D_in is input dimension;</span></span><br><span class="line"><span class="comment"># H is hidden dimension; D_out is output dimension.</span></span><br><span class="line">N, D_in, H, D_out = <span class="number">64</span>, <span class="number">1000</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create random Tensors to hold inputs and outputs</span></span><br><span class="line">x = torch.randn(N, D_in)</span><br><span class="line">y = torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct our model by instantiating the class defined above</span></span><br><span class="line">model = TwoLayerNet(D_in, H, D_out)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construct our loss function and an Optimizer. The call to model.parameters()</span></span><br><span class="line"><span class="comment"># in the SGD constructor will contain the learnable parameters of the two</span></span><br><span class="line"><span class="comment"># nn.Linear modules which are members of the model.</span></span><br><span class="line">criterion = torch.nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    <span class="comment"># Forward pass: Compute predicted y by passing x to the model</span></span><br><span class="line">    y_pred = model(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute and print loss</span></span><br><span class="line">    loss = criterion(y_pred, y)</span><br><span class="line">    print(t, loss.item())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Zero gradients, perform a backward pass, and update the weights.</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>
<pre><code>0 684.3630981445312
1 634.8236083984375
…………
498 1.6948175471043214e-05
499 1.6512673028046265e-05
</code></pre>
<h1>FizzBuzz</h1>
<p>FizzBuzz是一个简单的小游戏。游戏规则如下：从1开始往上数数，当遇到3的倍数的时候，说fizz，当遇到5的倍数，说buzz，当遇到15的倍数，就说fizzbuzz，其他情况下则正常数数。</p>
<p>我们可以写一个简单的小程序来决定要返回正常数值还是fizz, buzz 或者 fizzbuzz。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fizz_buzz_encode</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">15</span> == <span class="number">0</span>:  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">5</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">3</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:              <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fizz_buzz_decode</span>(<span class="params">num, index</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [str(num), <span class="string">&#x27;fizz&#x27;</span>, <span class="string">&#x27;buzz&#x27;</span>, <span class="string">&#x27;fizzbuzz&#x27;</span>][index]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们首先创建训练数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">NUM_DIGITS = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数字进行二进制显示为array</span></span><br><span class="line"><span class="comment"># Represent each input by an array of its binary digits.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_encode</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.array([num &gt;&gt; d &amp; <span class="number">1</span> <span class="keyword">for</span> d <span class="keyword">in</span> range(NUM_DIGITS)])</span><br><span class="line"></span><br><span class="line">trX = torch.Tensor([binary_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>, <span class="number">2</span> ** NUM_DIGITS)])</span><br><span class="line">trY = torch.LongTensor([fizz_buzz_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>, <span class="number">2</span> ** NUM_DIGITS)])</span><br></pre></td></tr></table></figure>
<p>然后我们用PyTorch定义模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define the model</span></span><br><span class="line">NUM_HIDDEN = <span class="number">100</span></span><br><span class="line">model = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(NUM_DIGITS, NUM_HIDDEN),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(NUM_HIDDEN, <span class="number">4</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>为了让我们的模型学会FizzBuzz这个游戏，我们需要定义一个损失函数，和一个优化算法。</li>
<li>这个优化算法会不断优化（降低）损失函数，使得模型的在该任务上取得尽可能低的损失值。</li>
<li>损失值低往往表示我们的模型表现好，损失值高表示我们的模型表现差。</li>
<li>由于FizzBuzz游戏本质上是一个分类问题，我们选用Cross Entropyy Loss函数。</li>
<li>优化函数我们选用Stochastic Gradient Descent。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_fn = torch.nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.05</span>)</span><br></pre></td></tr></table></figure>
<p>以下是模型的训练代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BATCH_SIZE = <span class="number">128</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">0</span>, len(trX), BATCH_SIZE):</span><br><span class="line">        end = start + BATCH_SIZE</span><br><span class="line">        testX = trX[start:end]</span><br><span class="line">        testY = trY[start:end]</span><br><span class="line"></span><br><span class="line">        y_pred = model(testX)</span><br><span class="line">        loss = loss_fn(y_pred, testY)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    loss = loss_fn(model(trX), trY).item()</span><br><span class="line">    print(<span class="string">&#x27;epoch:&#x27;</span>, epoch, <span class="string">&#x27;loss:&#x27;</span>, loss)</span><br></pre></td></tr></table></figure>
<pre><code>epoch: 0 loss: 1.1895811557769775
epoch: 1 loss: 1.1572147607803345
…………
epoch: 5097 loss: 0.02661093883216381
epoch: 5098 loss: 0.026590632274746895
epoch: 5099 loss: 0.026588384062051773
…………
epoch: 8016 loss: 0.011458768509328365
epoch: 8017 loss: 0.011454952880740166
epoch: 8018 loss: 0.011453792452812195
…………
epoch: 9998 loss: 0.00786476582288742
epoch: 9999 loss: 0.00786191038787365
</code></pre>
<p>最后我们用训练好的模型尝试在1到100这些数字上玩FizzBuzz游戏</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testX = torch.Tensor([binary_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)])</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    pred_Y = model(testX)</span><br><span class="line">predictions = zip(range(<span class="number">1</span>, <span class="number">101</span>), pred_Y.max(<span class="number">1</span>)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>显示最后玩的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num, index <span class="keyword">in</span> predictions:</span><br><span class="line">    print(fizz_buzz_decode(num, index), end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz 21 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 69 buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz 81 82 83 84 buzz 86 87 88 89 fizzbuzz 91 92 93 94 buzz fizz 97 98 fizz buzz
</code></pre>
<p>计算总和， 和哪些错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分类问题使用tensor.max(1) 返回最大值的index</span></span><br><span class="line"></span><br><span class="line">print(np.sum(pred_Y.max(<span class="number">1</span>)[<span class="number">1</span>].numpy() == np.array([fizz_buzz_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)])))</span><br></pre></td></tr></table></figure>
<pre><code>94
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pred_Y.max(<span class="number">1</span>)[<span class="number">1</span>].numpy() == np.array([fizz_buzz_encode(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)])</span><br></pre></td></tr></table></figure>
<pre><code>array([ True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True, False,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True, False,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True, False,
        True,  True, False,  True,  True, False,  True,  True,  True,
        True,  True, False,  True,  True,  True,  True,  True,  True,
        True])
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pred_Y.max(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>torch.return_types.max(
values=tensor([ 5.9531,  5.9475,  5.8658,  7.1499, 10.3761,  8.2045,  8.1089,  6.6718,
         5.6398,  7.5722,  6.4976,  9.0869,  8.1241,  8.0379,  8.4377,  7.2665,
         7.3191,  7.8744,  5.6651,  7.6147,  2.2065,  7.8375,  4.2420,  6.6890,
         3.5175,  9.0680,  8.0666,  8.6170,  8.5703,  7.5231,  7.3321,  6.3975,
         3.3405,  7.5249,  8.5877,  7.6400,  5.8178,  7.7374,  4.2418,  6.5080,
         7.3046,  6.7514,  2.8480,  8.3515,  5.0900,  8.7313,  6.0416,  8.3804,
         8.2009,  4.7483,  4.1110,  4.2541,  3.0316,  4.7115,  8.0126,  8.8917,
         2.6943,  6.2795,  8.0649,  5.5002,  7.3595,  6.0792,  3.9122,  6.3986,
         6.1323,  6.6845,  7.4449,  7.3432,  4.2463,  8.6458,  8.3745,  8.8894,
         7.9096,  8.1622,  3.5034,  7.2827,  8.8453,  7.8358,  5.6428,  6.7707,
         1.3065,  5.7157,  3.3958,  4.8879,  5.4819,  7.6762,  4.3674,  7.3603,
         8.4167,  6.3594,  4.1352,  8.4632,  5.4859,  5.7701,  6.6684,  8.2688,
         8.7533,  5.7605,  5.5259,  9.0591]),
indices=tensor([0, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 1, 0, 0, 3, 0, 0, 1, 0, 2, 0, 0, 0, 1,
        2, 0, 1, 0, 0, 3, 0, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 1, 0, 0, 3, 0, 0, 1,
        0, 2, 1, 0, 0, 1, 2, 0, 1, 0, 0, 3, 0, 0, 1, 0, 2, 1, 0, 0, 0, 2, 0, 1,
        0, 0, 3, 0, 0, 1, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 1,
        0, 0, 1, 2]))
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pred_Y.max(<span class="number">1</span>)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 1, 0, 0, 3, 0, 0, 1, 0, 2, 0, 0, 0, 1,
        2, 0, 1, 0, 0, 3, 0, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 1, 0, 0, 3, 0, 0, 1,
        0, 2, 1, 0, 0, 1, 2, 0, 1, 0, 0, 3, 0, 0, 1, 0, 2, 1, 0, 0, 0, 2, 0, 1,
        0, 0, 3, 0, 0, 1, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 1,
        0, 0, 1, 2])
</code></pre>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
</search>
